//+------------------------------------------------------------------+
//|                                                       IB60.mql5 |
//|                        Initial Balance Breakout 60min Strategy   |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "IB Breakout Strategy"
#property link      ""
#property version   "1.01"
#property strict

#include <Trade\Trade.mqh>

CTrade trade;

// Input Parameters
input group "=== Trading Session ==="
input int SessionStartHour = 16;       // Session Start Hour (GMT+2: 16 for US market 9:30 AM EST)
input int SessionStartMinute = 30;     // Session Start Minute
input int SessionEndHour = 23;         // Session End Hour (GMT+2: 23 for US market 4:00 PM EST)
input int SessionEndMinute = 0;        // Session End Minute

input group "=== Strategy Settings ==="
input int IBPeriodMinutes = 60;        // Initial Balance Period (minutes)
input ENUM_TIMEFRAMES CandleTimeframe = PERIOD_M30; // Candle Timeframe for Breakout
input bool BreakoutByClose = true;     // Breakout Measured by Close (vs High/Low)

input group "=== Risk Management ==="
input double RiskPercent = 1.0;        // Risk Percent per Trade
input double LotSize = 0.1;            // Fixed Lot Size (if RiskPercent = 0)
input double StopLossPercent = 0.0;    // Stop Loss % of Entry Price (0 = IB range)
input double TakeProfitPercent = 0.0;  // Take Profit % of Entry Price (0 = 2x IB range)
input bool UseTrailingStop = false;    // Use Trailing Stop
input double TrailingStopPercent = 0.5; // Trailing Stop % of Current Price

input group "=== Trade Management ==="
input bool OneTradePerDay = true;      // One Trade Per Day
input bool CloseAtSessionEnd = true;   // Close Positions at Session End

// Global Variables
double ibHigh = 0;
double ibLow = 0;
bool ibFormed = false;
bool tradeTakenToday = false;
datetime currentDay = 0;
datetime ibStartTime = 0;
datetime ibEndTime = 0;
bool longBreakout = false;
bool shortBreakout = false;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("IB60 Strategy Initialized");
   Print("IB Period: ", IBPeriodMinutes, " minutes");
   Print("Session: ", SessionStartHour, ":", SessionStartMinute, " - ", SessionEndHour, ":", SessionEndMinute);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("IB60 Strategy Deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check if new day
   datetime now = TimeCurrent();
   MqlDateTime timeStruct;
   TimeToStruct(now, timeStruct);
   
   datetime todayDate = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                      IntegerToString(timeStruct.mon) + "." + 
                                      IntegerToString(timeStruct.day));
   
   if(todayDate != currentDay)
   {
      // New day - reset variables
      currentDay = todayDate;
      ibFormed = false;
      tradeTakenToday = false;
      ibHigh = 0;
      ibLow = 0;
      longBreakout = false;
      shortBreakout = false;
      
      // Calculate IB start and end times for today
      ibStartTime = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                  IntegerToString(timeStruct.mon) + "." + 
                                  IntegerToString(timeStruct.day) + " " +
                                  IntegerToString(SessionStartHour) +":" + 
                                  IntegerToString(SessionStartMinute));
      ibEndTime = ibStartTime + IBPeriodMinutes * 60;
   }
   
   // Check if we're in trading session
   if(!IsInTradingSession(now))
   {
      if(CloseAtSessionEnd && PositionsTotal() > 0)
      {
         CloseAllPositions();
      }
      return;
   }
   
   // Form Initial Balance after period ends (wait for M30 candles to be indexed)
   // We need to be past 17:30 for the 17:00-17:30 candle to be available as bar 1
   if(!ibFormed && now >= ibEndTime + 60)  // Wait 1 minute after IB period ends
   {
      UpdateInitialBalance();
      
      if(ibHigh > 0 && ibLow > 0)
      {
         ibFormed = true;
         Print("✓ IB Formed - High: ", ibHigh, " Low: ", ibLow, " Range: ", (ibHigh - ibLow) / _Point, " points");
      }
      else
      {
         Print("✗ IB Formation FAILED - No candles found for today");
      }
   }
   
   // Check for breakout after IB is formed
   if(ibFormed && (!OneTradePerDay || !tradeTakenToday))
   {
      CheckForBreakout();
   }
   
   // Manage trailing stop
   if(UseTrailingStop)
   {
      ManageTrailingStop();
   }
}

//+------------------------------------------------------------------+
//| Check if current time is in trading session                      |
//+------------------------------------------------------------------+
bool IsInTradingSession(datetime time)
{
   MqlDateTime timeStruct;
   TimeToStruct(time, timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int startMinutes = SessionStartHour * 60 + SessionStartMinute;
   int endMinutes = SessionEndHour * 60 + SessionEndMinute;
   
   return (currentMinutes >= startMinutes && currentMinutes < endMinutes);
}

//+------------------------------------------------------------------+
//| Update Initial Balance high and low using M30 candles            |
//+------------------------------------------------------------------+
void UpdateInitialBalance()
{
   Print("Looking for IB candles. IB Period: ", TimeToString(ibStartTime, TIME_DATE|TIME_MINUTES), " - ", TimeToString(ibEndTime, TIME_MINUTES));
   
   // We need 2 M30 candles: 16:30-17:00 and 17:00-17:30
   // Look back through recent M30 candles to find those in the IB period
   int candlesFound = 0;
   
   for(int i = 1; i <= 10; i++)
   {
      datetime candleTime = iTime(_Symbol, PERIOD_M30, i);
      datetime candleEndTime = candleTime + 1800; // M30 candle ends 30 min later
      
      Print("  Checking bar ", i, ": ", TimeToString(candleTime, TIME_DATE|TIME_MINUTES), " (ends ", TimeToString(candleEndTime, TIME_MINUTES), ")");
      
      // Check if this M30 candle is from today AND starts within the IB period
      // We want candles at 16:30 and 17:00 (both start before 17:30) from the same day
      MqlDateTime candleStruct, ibStruct;
      TimeToStruct(candleTime, candleStruct);
      TimeToStruct(ibStartTime, ibStruct);
      
      bool sameDay = (candleStruct.year == ibStruct.year && 
                      candleStruct.mon == ibStruct.mon && 
                      candleStruct.day == ibStruct.day);
      
      if(sameDay && candleTime >= ibStartTime && candleTime < ibEndTime)
      {
         double high = iHigh(_Symbol, PERIOD_M30, i);
         double low = iLow(_Symbol, PERIOD_M30, i);
         
         if(ibHigh == 0 || high > ibHigh)
            ibHigh = high;
         
         if(ibLow == 0 || low < ibLow)
            ibLow = low;
         
         candlesFound++;
         Print("  >>> IB M30 Candle ", candlesFound, " at bar ", i, ": ", TimeToString(candleTime, TIME_MINUTES), " H=", high, " L=", low);
      }
      else
      {
         MqlDateTime candleStruct, ibStruct;
         TimeToStruct(candleTime, candleStruct);
         TimeToStruct(ibStartTime, ibStruct);
         bool sameDay = (candleStruct.year == ibStruct.year && candleStruct.mon == ibStruct.mon && candleStruct.day == ibStruct.day);
         
         if(!sameDay)
            Print("  ... Bar ", i, " is from different day");
         else
            Print("  ... Bar ", i, " outside IB period (need >= ", TimeToString(ibStartTime, TIME_MINUTES), " and < ", TimeToString(ibEndTime, TIME_MINUTES), ")");
      }
   }
   
   if(ibHigh > 0 && ibLow > 0)
   {
      Print(">>> IB Formed from ", candlesFound, " M30 candles: H=", ibHigh, " L=", ibLow, " Range=", (ibHigh-ibLow)/_Point, " points");
   }
   else
   {
      Print("!!! IB NOT FOUND - No M30 candles in period ", TimeToString(ibStartTime, TIME_MINUTES), " - ", TimeToString(ibEndTime, TIME_MINUTES));
   }
}

//+------------------------------------------------------------------+
//| Check for breakout of Initial Balance                            |
//+------------------------------------------------------------------+
void CheckForBreakout()
{
   // Get current candle data on the specified timeframe
   double close = iClose(_Symbol, CandleTimeframe, 1);  // Use bar 1 (last completed candle)
   double high = iHigh(_Symbol, CandleTimeframe, 1);
   double low = iLow(_Symbol, CandleTimeframe, 1);
   datetime candleTime = iTime(_Symbol, CandleTimeframe, 1);
   
   static datetime lastCheckedCandle = 0;
   if(candleTime == lastCheckedCandle)
      return;  // Already checked this candle
   
   lastCheckedCandle = candleTime;
   Print("Checking breakout on candle: ", TimeToString(candleTime, TIME_MINUTES), " Close=", close, " IB High=", ibHigh, " IB Low=", ibLow);
   
   // Check for long breakout
   if(!longBreakout && PositionsTotal() == 0)
   {
      bool breakout = false;
      
      if(BreakoutByClose)
         breakout = (close > ibHigh);
      else
         breakout = (high > ibHigh);
      
      if(breakout)
      {
         longBreakout = true;
         OpenLongPosition();
         tradeTakenToday = true;
         Print("Long Breakout Detected at ", close);
      }
   }
   
   // Check for short breakout
   if(!shortBreakout && PositionsTotal() == 0)
   {
      bool breakout = false;
      
      if(BreakoutByClose)
         breakout = (close < ibLow);
      else
         breakout = (low < ibLow);
      
      if(breakout)
      {
         shortBreakout = true;
         OpenShortPosition();
         tradeTakenToday = true;
         Print("Short Breakout Detected at ", close);
      }
   }
}

//+------------------------------------------------------------------+
//| Open Long Position                                                |
//+------------------------------------------------------------------+
void OpenLongPosition()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl = 0;
   double tp = 0;
   
   // Calculate Stop Loss
   if(StopLossPercent > 0)
   {
      sl = price - (price * StopLossPercent / 100.0);
   }
   else
   {
      sl = ibLow; // Use IB low as stop loss
   }
   
   // Calculate Take Profit
   double ibRange = ibHigh - ibLow;
   if(TakeProfitPercent > 0)
   {
      tp = price + (price * TakeProfitPercent / 100.0);
   }
   else
   {
      tp = price + (ibRange * 2); // 2x IB range
   }
   
   // Calculate lot size
   double lots = CalculateLotSize(price - sl);
   
   if(trade.Buy(lots, _Symbol, price, sl, tp, "IB60 Long"))
   {
      Print("Long position opened at ", price, " SL: ", sl, " TP: ", tp, " Lots: ", lots);
   }
   else
   {
      Print("Failed to open long position. Error: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Open Short Position                                               |
//+------------------------------------------------------------------+
void OpenShortPosition()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl = 0;
   double tp = 0;
   
   // Calculate Stop Loss
   if(StopLossPercent > 0)
   {
      sl = price + (price * StopLossPercent / 100.0);
   }
   else
   {
      sl = ibHigh; // Use IB high as stop loss
   }
   
   // Calculate Take Profit
   double ibRange = ibHigh - ibLow;
   if(TakeProfitPercent > 0)
   {
      tp = price - (price * TakeProfitPercent / 100.0);
   }
   else
   {
      tp = price - (ibRange * 2); // 2x IB range
   }
   
   // Calculate lot size
   double lots = CalculateLotSize(sl - price);
   
   if(trade.Sell(lots, _Symbol, price, sl, tp, "IB60 Short"))
   {
      Print("Short position opened at ", price, " SL: ", sl, " TP: ", tp, " Lots: ", lots);
   }
   else
   {
      Print("Failed to open short position. Error: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size based on risk                                 |
//+------------------------------------------------------------------+
double CalculateLotSize(double slDistance)
{
   if(RiskPercent <= 0)
      return LotSize;
   
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * RiskPercent / 100.0;
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   
   double slInTicks = slDistance / tickSize;
   double lots = riskAmount / (slInTicks * tickValue);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lots = MathFloor(lots / lotStep) * lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));
   
   return lots;
}

//+------------------------------------------------------------------+
//| Manage Trailing Stop                                             |
//+------------------------------------------------------------------+
void ManageTrailingStop()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      
      double positionOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      
      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
      {
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double newSL = currentPrice - (currentPrice * TrailingStopPercent / 100.0);
         
         if(newSL > currentSL && newSL < currentPrice)
         {
            trade.PositionModify(ticket, newSL, currentTP);
            Print("Trailing stop updated for long position. New SL: ", newSL);
         }
      }
      else if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
      {
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double newSL = currentPrice + (currentPrice * TrailingStopPercent / 100.0);
         
         if(newSL < currentSL && newSL > currentPrice)
         {
            trade.PositionModify(ticket, newSL, currentTP);
            Print("Trailing stop updated for short position. New SL: ", newSL);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close All Positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         trade.PositionClose(ticket);
         Print("Position closed at session end. Ticket: ", ticket);
      }
   }
}
//+------------------------------------------------------------------+