//+------------------------------------------------------------------+
//|                                                       IB60.mql5 |
//|                        Initial Balance Breakout 60min Strategy   |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "IB Breakout Strategy"
#property link      ""
#property version   "1.02"
#property strict

#include <Trade\Trade.mqh>

CTrade trade;

// Input Parameters
input group "=== Trading Session ==="
input int SessionStartHour = 16;       // Session Start Hour (GMT+2: 16 for US market 9:30 AM EST)
input int SessionStartMinute = 30;     // Session Start Minute
input int SessionEndHour = 23;         // Session End Hour (GMT+2: 23 for US market 4:00 PM EST)
input int SessionEndMinute = 0;        // Session End Minute

input group "=== Strategy Settings ==="
input int IBPeriodMinutes = 60;        // Initial Balance Period (minutes)
input ENUM_TIMEFRAMES CandleTimeframe = PERIOD_M30; // Candle Timeframe for Breakout
input bool UseRetracementEntry = true; // Use IB Retracement Entry (vs Breakout)
input bool BreakoutByClose = true;     // Breakout Measured by Close (vs High/Low)

input group "=== MONDAY Settings ==="
input bool Monday_Enabled = true;      // Enable Trading on Monday
input double Monday_RetracementEntry = 25.0;  // IB Retracement Entry Level %
input double Monday_RetracementSL = 50.0;     // IB Retracement Stop Loss Level %
input double Monday_ProfitTarget1 = 50.0;     // Profit Target 1 - IB by levels (%)
input double Monday_ProfitTarget2 = 100.0;    // Profit Target 2 - IB by levels (%)
input double Monday_MinIBSize = 0.0;          // Min IB Size % (0 = disabled)
input double Monday_MaxIBSize = 1.0;          // Max IB Size % (1 = disabled)
input bool Monday_AllowLong = true;           // Allow Long Trades
input bool Monday_AllowShort = true;          // Allow Short Trades

input group "=== TUESDAY Settings ==="
input bool Tuesday_Enabled = true;
input double Tuesday_RetracementEntry = 25.0;
input double Tuesday_RetracementSL = 50.0;
input double Tuesday_ProfitTarget1 = 50.0;
input double Tuesday_ProfitTarget2 = 100.0;
input double Tuesday_MinIBSize = 0.0;
input double Tuesday_MaxIBSize = 1.0;
input bool Tuesday_AllowLong = true;
input bool Tuesday_AllowShort = true;

input group "=== WEDNESDAY Settings ==="
input bool Wednesday_Enabled = true;
input double Wednesday_RetracementEntry = 25.0;
input double Wednesday_RetracementSL = 50.0;
input double Wednesday_ProfitTarget1 = 50.0;
input double Wednesday_ProfitTarget2 = 100.0;
input double Wednesday_MinIBSize = 0.0;
input double Wednesday_MaxIBSize = 1.0;
input bool Wednesday_AllowLong = true;
input bool Wednesday_AllowShort = true;

input group "=== THURSDAY Settings ==="
input bool Thursday_Enabled = true;
input double Thursday_RetracementEntry = 25.0;
input double Thursday_RetracementSL = 50.0;
input double Thursday_ProfitTarget1 = 50.0;
input double Thursday_ProfitTarget2 = 100.0;
input double Thursday_MinIBSize = 0.0;
input double Thursday_MaxIBSize = 1.0;
input bool Thursday_AllowLong = true;
input bool Thursday_AllowShort = true;

input group "=== FRIDAY Settings ==="
input bool Friday_Enabled = true;
input double Friday_RetracementEntry = 25.0;
input double Friday_RetracementSL = 50.0;
input double Friday_ProfitTarget1 = 50.0;
input double Friday_ProfitTarget2 = 100.0;
input double Friday_MinIBSize = 0.0;
input double Friday_MaxIBSize = 1.0;
input bool Friday_AllowLong = true;
input bool Friday_AllowShort = true;

input group "=== Risk Management ==="
input double RiskPercent = 1.0;        // Risk Percent per Trade
input double LotSize = 0.1;            // Fixed Lot Size (if RiskPercent = 0)
input bool UseTrailingStop = false;    // Use Trailing Stop
input double TrailingStopPercent = 0.5; // Trailing Stop % of Current Price

input group "=== Trade Management ==="
input bool OneTradePerDay = true;      // One Trade Per Day
input bool CloseAtSessionEnd = true;   // Close Positions at Session End
input bool UseOpeningCandleFilter = true; // Use Opening Candle Continuation Filter

input group "=== Partial Take Profit ==="
input bool UsePartialTP = true;        // Use Partial Take Profit
input double TP1_ClosePercent = 50.0;  // TP1: % of Position to Close
input double TP2_ClosePercent = 50.0;  // TP2: % of Position to Close (remaining)
input bool MoveToBreakEven = true;     // Move SL to Break-Even After TP1

// Global Variables
double ibHigh = 0;
double ibLow = 0;
bool ibFormed = false;
bool tradeTakenToday = false;
datetime currentDay = 0;
datetime ibStartTime = 0;
datetime ibEndTime = 0;
bool longBreakout = false;
bool shortBreakout = false;
bool openingCandleBullish = false;  // Opening candle direction
bool openingCandleSet = false;       // Opening candle analyzed

// Day-specific settings (loaded based on current day)
struct DaySettings
{
   bool enabled;
   double retracementEntry;
   double retracementSL;
   double profitTarget1;
   double profitTarget2;
   double minIBSize;
   double maxIBSize;
   bool allowLong;
   bool allowShort;
};
DaySettings currentDaySettings;

// Partial TP tracking
ulong mainTicket = 0;           // Main position ticket
double initialLots = 0;         // Initial position size
bool tp1Hit = false;            // TP1 reached
bool tp2Hit = false;            // TP2 reached
bool movedToBreakEven = false;  // SL moved to break-even

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("IB60 Strategy Initialized");
   Print("IB Period: ", IBPeriodMinutes, " minutes");
   Print("Session: ", SessionStartHour, ":", SessionStartMinute, " - ", SessionEndHour, ":", SessionEndMinute);
   Print("Strategy Mode: ", UseRetracementEntry ? "Retracement Entry" : "Breakout Entry");
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Load day-specific settings based on current day of week          |
//+------------------------------------------------------------------+
void LoadDaySettings(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: // Monday
         currentDaySettings.enabled = Monday_Enabled;
         currentDaySettings.retracementEntry = Monday_RetracementEntry;
         currentDaySettings.retracementSL = Monday_RetracementSL;
         currentDaySettings.profitTarget1 = Monday_ProfitTarget1;
         currentDaySettings.profitTarget2 = Monday_ProfitTarget2;
         currentDaySettings.minIBSize = Monday_MinIBSize;
         currentDaySettings.maxIBSize = Monday_MaxIBSize;
         currentDaySettings.allowLong = Monday_AllowLong;
         currentDaySettings.allowShort = Monday_AllowShort;
         Print("Loaded MONDAY settings");
         break;
      case 2: // Tuesday
         currentDaySettings.enabled = Tuesday_Enabled;
         currentDaySettings.retracementEntry = Tuesday_RetracementEntry;
         currentDaySettings.retracementSL = Tuesday_RetracementSL;
         currentDaySettings.profitTarget1 = Tuesday_ProfitTarget1;
         currentDaySettings.profitTarget2 = Tuesday_ProfitTarget2;
         currentDaySettings.minIBSize = Tuesday_MinIBSize;
         currentDaySettings.maxIBSize = Tuesday_MaxIBSize;
         currentDaySettings.allowLong = Tuesday_AllowLong;
         currentDaySettings.allowShort = Tuesday_AllowShort;
         Print("Loaded TUESDAY settings");
         break;
      case 3: // Wednesday
         currentDaySettings.enabled = Wednesday_Enabled;
         currentDaySettings.retracementEntry = Wednesday_RetracementEntry;
         currentDaySettings.retracementSL = Wednesday_RetracementSL;
         currentDaySettings.profitTarget1 = Wednesday_ProfitTarget1;
         currentDaySettings.profitTarget2 = Wednesday_ProfitTarget2;
         currentDaySettings.minIBSize = Wednesday_MinIBSize;
         currentDaySettings.maxIBSize = Wednesday_MaxIBSize;
         currentDaySettings.allowLong = Wednesday_AllowLong;
         currentDaySettings.allowShort = Wednesday_AllowShort;
         Print("Loaded WEDNESDAY settings");
         break;
      case 4: // Thursday
         currentDaySettings.enabled = Thursday_Enabled;
         currentDaySettings.retracementEntry = Thursday_RetracementEntry;
         currentDaySettings.retracementSL = Thursday_RetracementSL;
         currentDaySettings.profitTarget1 = Thursday_ProfitTarget1;
         currentDaySettings.profitTarget2 = Thursday_ProfitTarget2;
         currentDaySettings.minIBSize = Thursday_MinIBSize;
         currentDaySettings.maxIBSize = Thursday_MaxIBSize;
         currentDaySettings.allowLong = Thursday_AllowLong;
         currentDaySettings.allowShort = Thursday_AllowShort;
         Print("Loaded THURSDAY settings");
         break;
      case 5: // Friday
         currentDaySettings.enabled = Friday_Enabled;
         currentDaySettings.retracementEntry = Friday_RetracementEntry;
         currentDaySettings.retracementSL = Friday_RetracementSL;
         currentDaySettings.profitTarget1 = Friday_ProfitTarget1;
         currentDaySettings.profitTarget2 = Friday_ProfitTarget2;
         currentDaySettings.minIBSize = Friday_MinIBSize;
         currentDaySettings.maxIBSize = Friday_MaxIBSize;
         currentDaySettings.allowLong = Friday_AllowLong;
         currentDaySettings.allowShort = Friday_AllowShort;
         Print("Loaded FRIDAY settings");
         break;
      default: // Weekend
         currentDaySettings.enabled = false;
         Print("Weekend - Trading disabled");
         break;
   }
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("IB60 Strategy Deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check if new day
   datetime now = TimeCurrent();
   MqlDateTime timeStruct;
   TimeToStruct(now, timeStruct);
   
   datetime todayDate = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                      IntegerToString(timeStruct.mon) + "." + 
                                      IntegerToString(timeStruct.day));
   
   if(todayDate != currentDay)
   {
      // New day - reset variables
      currentDay = todayDate;
      ibFormed = false;
      tradeTakenToday = false;
      ibHigh = 0;
      ibLow = 0;
      longBreakout = false;
      shortBreakout = false;
      openingCandleSet = false;
      
      // Reset partial TP tracking
      mainTicket = 0;
      initialLots = 0;
      tp1Hit = false;
      tp2Hit = false;
      movedToBreakEven = false;
      
      // Load day-specific settings
      LoadDaySettings(timeStruct.day_of_week);
      
      // Calculate IB start and end times for today
      ibStartTime = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                  IntegerToString(timeStruct.mon) + "." + 
                                  IntegerToString(timeStruct.day) + " " +
                                  IntegerToString(SessionStartHour) +":" + 
                                  IntegerToString(SessionStartMinute));
      ibEndTime = ibStartTime + IBPeriodMinutes * 60;
   }
   
   // Check if trading is enabled for current day
   if(!currentDaySettings.enabled)
      return;
   
   // Check if we're in trading session
   if(!IsInTradingSession(now))
   {
      if(CloseAtSessionEnd && PositionsTotal() > 0)
      {
         CloseAllPositions();
      }
      return;
   }
   
   // Form Initial Balance after period ends (wait for M30 candles to be indexed)
   // We need to be past 17:30 for the 17:00-17:30 candle to be available as bar 1
   if(!ibFormed && now >= ibEndTime + 60)  // Wait 1 minute after IB period ends
   {
      UpdateInitialBalance();
      
      if(ibHigh > 0 && ibLow > 0)
      {
         double ibRange = ibHigh - ibLow;
         double ibRangePercent = (ibRange / ibLow) * 100.0;
         
         Print("✓ IB Formed - High: ", ibHigh, " Low: ", ibLow, " Range: ", ibRange, " (", DoubleToString(ibRangePercent, 2), "%)");
         
         // Check IB size filters
         if(currentDaySettings.minIBSize > 0 && ibRangePercent < currentDaySettings.minIBSize)
         {
            Print("⊘ IB Range too small (", DoubleToString(ibRangePercent, 2), "% < ", currentDaySettings.minIBSize, "%) - No trading today");
            return;
         }
         
         if(currentDaySettings.maxIBSize < 1.0 && ibRangePercent > currentDaySettings.maxIBSize)
         {
            Print("⊘ IB Range too large (", DoubleToString(ibRangePercent, 2), "% > ", currentDaySettings.maxIBSize, "%) - No trading today");
            return;
         }
         
         ibFormed = true;
         
         // Analyze opening candle direction (60-min IB candle)
         if(UseOpeningCandleFilter && !openingCandleSet)
         {
            double ibOpen = iOpen(_Symbol, PERIOD_H1, 1);   // Opening price of IB period
            double ibClose = iClose(_Symbol, PERIOD_H1, 1); // Closing price of IB period
            openingCandleBullish = (ibClose > ibOpen);
            openingCandleSet = true;
            
            string direction = openingCandleBullish ? "Bullish" : "Bearish";
            Print("✓ Opening Candle (60min): ", direction, " | Open: ", ibOpen, " Close: ", ibClose);
         }
      }
      else
      {
         Print("✗ IB Formation FAILED - No candles found for today");
      }
   }
   
   // Check for breakout or retracement entry after IB is formed
   if(ibFormed && (!OneTradePerDay || !tradeTakenToday))
   {
      if(UseRetracementEntry)
         CheckForRetracementEntry();
      else
         CheckForBreakout();
   }
   
   // Manage partial take profit
   if(UsePartialTP && mainTicket > 0)
   {
      ManagePartialTP();
   }
   
   // Manage trailing stop
   if(UseTrailingStop)
   {
      ManageTrailingStop();
   }
}

//+------------------------------------------------------------------+
//| Check if current time is in trading session                      |
//+------------------------------------------------------------------+
bool IsInTradingSession(datetime time)
{
   MqlDateTime timeStruct;
   TimeToStruct(time, timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int startMinutes = SessionStartHour * 60 + SessionStartMinute;
   int endMinutes = SessionEndHour * 60 + SessionEndMinute;
   
   return (currentMinutes >= startMinutes && currentMinutes < endMinutes);
}

//+------------------------------------------------------------------+
//| Update Initial Balance high and low using M30 candles            |
//+------------------------------------------------------------------+
void UpdateInitialBalance()
{
   Print("Looking for IB candles. IB Period: ", TimeToString(ibStartTime, TIME_DATE|TIME_MINUTES), " - ", TimeToString(ibEndTime, TIME_MINUTES));
   
   // We need 2 M30 candles: 16:30-17:00 and 17:00-17:30
   // Look back through recent M30 candles to find those in the IB period
   int candlesFound = 0;
   
   for(int i = 1; i <= 10; i++)
   {
      datetime candleTime = iTime(_Symbol, PERIOD_M30, i);
      datetime candleEndTime = candleTime + 1800; // M30 candle ends 30 min later
      
      Print("  Checking bar ", i, ": ", TimeToString(candleTime, TIME_DATE|TIME_MINUTES), " (ends ", TimeToString(candleEndTime, TIME_MINUTES), ")");
      
      // Check if this M30 candle is from today AND starts within the IB period
      // We want candles at 16:30 and 17:00 (both start before 17:30) from the same day
      MqlDateTime candleStruct, ibStruct;
      TimeToStruct(candleTime, candleStruct);
      TimeToStruct(ibStartTime, ibStruct);
      
      bool sameDay = (candleStruct.year == ibStruct.year && 
                      candleStruct.mon == ibStruct.mon && 
                      candleStruct.day == ibStruct.day);
      
      if(sameDay && candleTime >= ibStartTime && candleTime < ibEndTime)
      {
         double high = iHigh(_Symbol, PERIOD_M30, i);
         double low = iLow(_Symbol, PERIOD_M30, i);
         
         if(ibHigh == 0 || high > ibHigh)
            ibHigh = high;
         
         if(ibLow == 0 || low < ibLow)
            ibLow = low;
         
         candlesFound++;
         Print("  >>> IB M30 Candle ", candlesFound, " at bar ", i, ": ", TimeToString(candleTime, TIME_MINUTES), " H=", high, " L=", low);
      }
      else
      {
         MqlDateTime candleStruct, ibStruct;
         TimeToStruct(candleTime, candleStruct);
         TimeToStruct(ibStartTime, ibStruct);
         bool sameDay = (candleStruct.year == ibStruct.year && candleStruct.mon == ibStruct.mon && candleStruct.day == ibStruct.day);
         
         if(!sameDay)
            Print("  ... Bar ", i, " is from different day");
         else
            Print("  ... Bar ", i, " outside IB period (need >= ", TimeToString(ibStartTime, TIME_MINUTES), " and < ", TimeToString(ibEndTime, TIME_MINUTES), ")");
      }
   }
   
   if(ibHigh > 0 && ibLow > 0)
   {
      Print(">>> IB Formed from ", candlesFound, " M30 candles: H=", ibHigh, " L=", ibLow, " Range=", (ibHigh-ibLow)/_Point, " points");
   }
   else
   {
      Print("!!! IB NOT FOUND - No M30 candles in period ", TimeToString(ibStartTime, TIME_MINUTES), " - ", TimeToString(ibEndTime, TIME_MINUTES));
   }
}

//+------------------------------------------------------------------+
//| Check for IB Retracement Entry                                   |
//+------------------------------------------------------------------+
void CheckForRetracementEntry()
{
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ibRange = ibHigh - ibLow;
   
   // Calculate retracement levels
   double retracementLevel = currentDaySettings.retracementEntry / 100.0;
   double longEntryPrice = ibHigh - (ibRange * retracementLevel);
   double shortEntryPrice = ibLow + (ibRange * retracementLevel);
   
   static datetime lastCheckedCandle = 0;
   datetime candleTime = iTime(_Symbol, CandleTimeframe, 1);
   
   if(candleTime == lastCheckedCandle)
      return;
   
   lastCheckedCandle = candleTime;
   
   // Check for long retracement entry
   if(!longBreakout && PositionsTotal() == 0 && currentDaySettings.allowLong)
   {
      double close = iClose(_Symbol, CandleTimeframe, 1);
      double low = iLow(_Symbol, CandleTimeframe, 1);
      
      // Price must have broken above IB high first, then retraced back
      bool priceAboveIB = (iHigh(_Symbol, CandleTimeframe, 1) > ibHigh);
      bool retracedToEntry = (low <= longEntryPrice && close >= longEntryPrice);
      
      // Apply opening candle filter
      if(UseOpeningCandleFilter && !openingCandleBullish)
      {
         if(priceAboveIB && retracedToEntry)
            Print("⊘ Long retracement ignored - Opening candle was bearish");
         return;
      }
      
      if(priceAboveIB && retracedToEntry)
      {
         longBreakout = true;
         Print("✓ Long Retracement Entry at ", longEntryPrice, " (", currentDaySettings.retracementEntry, "% into IB)");
         OpenLongPosition();
         tradeTakenToday = true;
         if(OneTradePerDay) return;
      }
   }
   
   // Check for short retracement entry
   if(!shortBreakout && PositionsTotal() == 0 && currentDaySettings.allowShort)
   {
      double close = iClose(_Symbol, CandleTimeframe, 1);
      double high = iHigh(_Symbol, CandleTimeframe, 1);
      
      // Price must have broken below IB low first, then retraced back
      bool priceBelowIB = (iLow(_Symbol, CandleTimeframe, 1) < ibLow);
      bool retracedToEntry = (high >= shortEntryPrice && close <= shortEntryPrice);
      
      // Apply opening candle filter
      if(UseOpeningCandleFilter && openingCandleBullish)
      {
         if(priceBelowIB && retracedToEntry)
            Print("⊘ Short retracement ignored - Opening candle was bullish");
         return;
      }
      
      if(priceBelowIB && retracedToEntry)
      {
         shortBreakout = true;
         Print("✓ Short Retracement Entry at ", shortEntryPrice, " (", currentDaySettings.retracementEntry, "% into IB)");
         OpenShortPosition();
         tradeTakenToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Check for breakout of Initial Balance                            |
//+------------------------------------------------------------------+
void CheckForBreakout()
{
   // Get current candle data on the specified timeframe
   double close = iClose(_Symbol, CandleTimeframe, 1);  // Use bar 1 (last completed candle)
   double high = iHigh(_Symbol, CandleTimeframe, 1);
   double low = iLow(_Symbol, CandleTimeframe, 1);
   datetime candleTime = iTime(_Symbol, CandleTimeframe, 1);
   
   static datetime lastCheckedCandle = 0;
   if(candleTime == lastCheckedCandle)
      return;  // Already checked this candle
   
   lastCheckedCandle = candleTime;
   Print("Checking breakout on candle: ", TimeToString(candleTime, TIME_MINUTES), " Close=", close, " IB High=", ibHigh, " IB Low=", ibLow);
   
   // Check for long breakout
   if(!longBreakout && PositionsTotal() == 0)
   {
      bool breakout = false;
      
      if(BreakoutByClose)
         breakout = (close > ibHigh);
      else
         breakout = (high > ibHigh);
      
      // Apply opening candle filter
      if(UseOpeningCandleFilter && !openingCandleBullish)
      {
         if(breakout)
            Print("⊘ Long breakout ignored - Opening candle was bearish");
         breakout = false;
      }
      
      if(breakout)
      {
         longBreakout = true;
         OpenLongPosition();
         tradeTakenToday = true;
         if(OneTradePerDay) return;
      }
   }
   
   // Check for short breakout
   if(!shortBreakout && PositionsTotal() == 0)
   {
      bool breakout = false;
      
      if(BreakoutByClose)
         breakout = (close < ibLow);
      else
         breakout = (low < ibLow);
      
      // Apply opening candle filter
      if(UseOpeningCandleFilter && openingCandleBullish)
      {
         if(breakout)
            Print("⊘ Short breakout ignored - Opening candle was bullish");
         breakout = false;
      }
      
      if(breakout)
      {
         shortBreakout = true;
         OpenShortPosition();
         tradeTakenToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Open Long Position                                                |
//+------------------------------------------------------------------+
void OpenLongPosition()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl = 0;
   double tp = 0;
   double ibRange = ibHigh - ibLow;
   
   // Calculate Stop Loss based on retracement SL level
   if(UseRetracementEntry)
   {
      double slLevel = currentDaySettings.retracementSL / 100.0;
      sl = ibHigh - (ibRange * slLevel);
   }
   else
   {
      sl = ibLow; // Use IB low as stop loss for breakout
   }
   
   // Calculate Take Profit based on day settings
   double tp2Multiplier = currentDaySettings.profitTarget2 / 100.0;
   tp = price + (ibRange * tp2Multiplier);
   
   // Calculate lot size
   double lots = CalculateLotSize(price - sl);
   
   if(trade.Buy(lots, _Symbol, price, sl, tp, "IB60 Long"))
   {
      mainTicket = trade.ResultOrder();
      initialLots = lots;
      Print("✓ Long position opened at ", price, " SL: ", sl, " TP: ", tp, " Lots: ", lots);
      if(UsePartialTP)
         Print("  Partial TP: TP1=", currentDaySettings.profitTarget1, "% (", TP1_ClosePercent, "%), TP2=", currentDaySettings.profitTarget2, "% (", TP2_ClosePercent, "%)");
   }
   else
   {
      Print("✗ Failed to open long position. Error: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Open Short Position                                               |
//+------------------------------------------------------------------+
void OpenShortPosition()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl = 0;
   double tp = 0;
   double ibRange = ibHigh - ibLow;
   
   // Calculate Stop Loss based on retracement SL level
   if(UseRetracementEntry)
   {
      double slLevel = currentDaySettings.retracementSL / 100.0;
      sl = ibLow + (ibRange * slLevel);
   }
   else
   {
      sl = ibHigh; // Use IB high as stop loss for breakout
   }
   
   // Calculate Take Profit based on day settings
   double tp2Multiplier = currentDaySettings.profitTarget2 / 100.0;
   tp = price - (ibRange * tp2Multiplier);
   
   // Calculate lot size
   double lots = CalculateLotSize(sl - price);
   
   if(trade.Sell(lots, _Symbol, price, sl, tp, "IB60 Short"))
   {
      mainTicket = trade.ResultOrder();
      initialLots = lots;
      Print("✓ Short position opened at ", price, " SL: ", sl, " TP: ", tp, " Lots: ", lots);
      if(UsePartialTP)
         Print("  Partial TP: TP1=", currentDaySettings.profitTarget1, "% (", TP1_ClosePercent, "%), TP2=", currentDaySettings.profitTarget2, "% (", TP2_ClosePercent, "%)");
   }
   else
   {
      Print("✗ Failed to open short position. Error: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size based on risk                                 |
//+------------------------------------------------------------------+
double CalculateLotSize(double slDistance)
{
   if(RiskPercent <= 0)
      return LotSize;
   
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * RiskPercent / 100.0;
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   
   double slInTicks = slDistance / tickSize;
   double lots = riskAmount / (slInTicks * tickValue);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lots = MathFloor(lots / lotStep) * lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));
   
   return lots;
}

//+------------------------------------------------------------------+
//| Manage Trailing Stop                                             |
//+------------------------------------------------------------------+
void ManageTrailingStop()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      
      double positionOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      
      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
      {
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double newSL = currentPrice - (currentPrice * TrailingStopPercent / 100.0);
         
         if(newSL > currentSL && newSL < currentPrice)
         {
            trade.PositionModify(ticket, newSL, currentTP);
            Print("Trailing stop updated for long position. New SL: ", newSL);
         }
      }
      else if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
      {
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double newSL = currentPrice + (currentPrice * TrailingStopPercent / 100.0);
         
         if(newSL < currentSL && newSL > currentPrice)
         {
            trade.PositionModify(ticket, newSL, currentTP);
            Print("Trailing stop updated for short position. New SL: ", newSL);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Manage Partial Take Profit                                       |
//+------------------------------------------------------------------+
void ManagePartialTP()
{
   // Check if position still exists
   if(!PositionSelectByTicket(mainTicket))
   {
      mainTicket = 0;
      return;
   }
   
   double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentPrice = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double currentLots = PositionGetDouble(POSITION_VOLUME);
   
   double ibRange = ibHigh - ibLow;
   bool isLong = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY);
   
   // Calculate profit in IB range percentage
   double profitPercent = isLong ? 
                          ((currentPrice - entryPrice) / ibRange) * 100.0 : 
                          ((entryPrice - currentPrice) / ibRange) * 100.0;
   
   // Check TP1
   if(!tp1Hit && profitPercent >= currentDaySettings.profitTarget1)
   {
      double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double closeVolume = MathFloor((initialLots * TP1_ClosePercent / 100.0) / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume <= currentLots)
      {
         if(trade.PositionClosePartial(mainTicket, closeVolume))
         {
            tp1Hit = true;
            Print("✓ TP1 Hit (", currentDaySettings.profitTarget1, "% IB): Closed ", TP1_ClosePercent, "% (", closeVolume, " lots) at ", currentPrice);
            
            // Move to break-even after TP1
            if(MoveToBreakEven && !movedToBreakEven)
            {
               double currentSL = PositionGetDouble(POSITION_SL);
               double currentTP = PositionGetDouble(POSITION_TP);
               
               if(trade.PositionModify(mainTicket, entryPrice, currentTP))
               {
                  movedToBreakEven = true;
                  Print("✓ Stop Loss moved to Break-Even: ", entryPrice);
               }
            }
         }
      }
   }
   
   // Check TP2 (final target is handled by main TP order)
   if(tp1Hit && !tp2Hit && profitPercent >= currentDaySettings.profitTarget2)
   {
      // Close remaining position or let main TP handle it
      tp2Hit = true;
      Print("✓ TP2 Hit (", currentDaySettings.profitTarget2, "% IB) at ", currentPrice);
   }
}

//+------------------------------------------------------------------+
//| Close All Positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         trade.PositionClose(ticket);
         Print("Position closed at session end. Ticket: ", ticket);
      }
   }
}
//+------------------------------------------------------------------+