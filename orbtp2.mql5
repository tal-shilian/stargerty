//+------------------------------------------------------------------+
//|                                                      orbtp2.mq5  |
//|                        ORB Strategy with Trailing Stop           |
//+------------------------------------------------------------------+
#property copyright "ORB Strategy"
#property version   "1.00"
#property strict

input group "=== General Settings ==="
input double MaxLoss = 900.0;                    // Max Loss $
input double LotSize = 0.1;                      // Lot Size
input bool UseVirtualTPSL = true;                // Use Virtual TP/SL

input group "=== Monday Settings ==="
input bool TradeOnMonday = true;                 // Trade on Monday
input bool Monday_TradeBreakout = true;          // Trade ORB breakout
input bool Monday_TradeBreakdown = true;         // Trade ORB breakdown
input double Monday_ProfitTarget = 50.0;         // Profit target (% of ORB size)
input double Monday_StopLoss = 100.0;            // Stop loss (% of ORB size)
input double Monday_MinORBSize = 0.0;            // Min ORB size %
input double Monday_MaxORBSize = 0.5;            // Max ORB size %
input bool Monday_ActivateMoveStop = true;       // Activate Move Stop?
input double Monday_TriggerPercent = 85.0;       // Trigger %
input double Monday_TargetPercent = 20.0;        // Target %

input group "=== Tuesday Settings ==="
input bool TradeOnTuesday = true;                // Trade on Tuesday
input bool Tuesday_TradeBreakout = true;         // Trade ORB breakout
input bool Tuesday_TradeBreakdown = true;        // Trade ORB breakdown
input double Tuesday_ProfitTarget = 50.0;        // Profit target (% of ORB size)
input double Tuesday_StopLoss = 100.0;           // Stop loss (% of ORB size)
input double Tuesday_MinORBSize = 0.0;           // Min ORB size %
input double Tuesday_MaxORBSize = 0.5;           // Max ORB size %
input bool Tuesday_ActivateMoveStop = true;      // Activate Move Stop?
input double Tuesday_TriggerPercent = 85.0;      // Trigger %
input double Tuesday_TargetPercent = 20.0;       // Target %

input group "=== Wednesday Settings ==="
input bool TradeOnWednesday = true;              // Trade on Wednesday
input bool Wednesday_TradeBreakout = true;       // Trade ORB breakout
input bool Wednesday_TradeBreakdown = true;      // Trade ORB breakdown
input double Wednesday_ProfitTarget = 50.0;      // Profit target (% of ORB size)
input double Wednesday_StopLoss = 100.0;         // Stop loss (% of ORB size)
input double Wednesday_MinORBSize = 0.0;         // Min ORB size %
input double Wednesday_MaxORBSize = 0.5;         // Max ORB size %
input bool Wednesday_ActivateMoveStop = true;    // Activate Move Stop?
input double Wednesday_TriggerPercent = 85.0;    // Trigger %
input double Wednesday_TargetPercent = 20.0;     // Target %

input group "=== Thursday Settings ==="
input bool TradeOnThursday = true;               // Trade on Thursday
input bool Thursday_TradeBreakout = true;        // Trade ORB breakout
input bool Thursday_TradeBreakdown = true;       // Trade ORB breakdown
input double Thursday_ProfitTarget = 50.0;       // Profit target (% of ORB size)
input double Thursday_StopLoss = 100.0;          // Stop loss (% of ORB size)
input double Thursday_MinORBSize = 0.0;          // Min ORB size %
input double Thursday_MaxORBSize = 0.5;          // Max ORB size %
input bool Thursday_ActivateMoveStop = true;     // Activate Move Stop?
input double Thursday_TriggerPercent = 85.0;     // Trigger %
input double Thursday_TargetPercent = 20.0;      // Target %

input group "=== Friday Settings ==="
input bool TradeOnFriday = true;                 // Trade on Friday
input bool Friday_TradeBreakout = true;          // Trade ORB breakout
input bool Friday_TradeBreakdown = true;         // Trade ORB breakdown
input double Friday_ProfitTarget = 50.0;         // Profit target (% of ORB size)
input double Friday_StopLoss = 100.0;            // Stop loss (% of ORB size)
input double Friday_MinORBSize = 0.0;            // Min ORB size %
input double Friday_MaxORBSize = 0.5;            // Max ORB size %
input bool Friday_ActivateMoveStop = true;       // Activate Move Stop?
input double Friday_TriggerPercent = 85.0;       // Trigger %
input double Friday_TargetPercent = 20.0;        // Target %

input group "=== Session Settings ==="
input string TimezoneInfo = "Broker Server Time"; // Timezone (info only)
input int SessionStartHour = 9;                  // Session Start Hour
input int SessionStartMinute = 30;               // Session Start Minute
input int SessionEndHour = 16;                   // Session End Hour
input int SessionEndMinute = 0;                  // Session End Minute

input group "=== ORB Time Settings ==="
input int ORB_StartHour = 9;                     // ORB Start Hour
input int ORB_StartMinute = 30;                  // ORB Start Minute
input int ORB_EndHour = 9;                       // ORB End Hour
input int ORB_EndMinute = 45;                    // ORB End Minute

// Global variables
double orbHigh = 0, orbLow = 0;
bool orbCalculated = false;
bool orbMessagePrinted = false;
datetime orbStartTime = 0;
datetime orbEndTime = 0;
double dailyProfit = 0;
datetime lastResetDate = 0;
bool breakoutTradeOpened = false;
bool breakdownTradeOpened = false;
bool sessionClosed = false;
bool maxLossPrinted = false;
int lastDealsTotal = 0;

// Virtual TP/SL tracking
struct VirtualLevels
{
   ulong ticket;
   double virtualTP;
   double virtualSL;
   double triggerPrice;
   bool trailingActivated;
};
VirtualLevels virtualPositions[];

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("ORB Strategy with Trailing Stop initialized");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("ORB Strategy stopped");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Reset daily loss counter
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   datetime currentDate = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                       IntegerToString(timeStruct.mon) + "." + 
                                       IntegerToString(timeStruct.day));
   
   if(currentDate != lastResetDate)
   {
      dailyProfit = 0;
      lastResetDate = currentDate;
      orbCalculated = false;
      orbMessagePrinted = false;
      breakoutTradeOpened = false;
      breakdownTradeOpened = false;
      sessionClosed = false;
      maxLossPrinted = false;
      lastDealsTotal = 0;
   }
   
   // Calculate daily profit from closed deals
   CalculateDailyProfit();
   
   // Check max loss
   if(dailyProfit <= -MaxLoss)
   {
      if(!maxLossPrinted)
      {
         Print("Max daily loss reached: $", MathAbs(dailyProfit));
         maxLossPrinted = true;
      }
      return;
   }
   
   // Check if we're within session time
   datetime sessionStart = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                        IntegerToString(timeStruct.mon) + "." + 
                                        IntegerToString(timeStruct.day) + " " +
                                        IntegerToString(SessionStartHour) + ":" + 
                                        IntegerToString(SessionStartMinute));
   
   datetime sessionEnd = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                      IntegerToString(timeStruct.mon) + "." + 
                                      IntegerToString(timeStruct.day) + " " +
                                      IntegerToString(SessionEndHour) + ":" + 
                                      IntegerToString(SessionEndMinute));
   
   if(TimeCurrent() < sessionStart || TimeCurrent() > sessionEnd) return;
   
   // Check if today is a trading day
   int dayOfWeek = timeStruct.day_of_week;
   bool shouldTrade = false;
   
   if(dayOfWeek == 1 && TradeOnMonday) shouldTrade = true;
   if(dayOfWeek == 2 && TradeOnTuesday) shouldTrade = true;
   if(dayOfWeek == 3 && TradeOnWednesday) shouldTrade = true;
   if(dayOfWeek == 4 && TradeOnThursday) shouldTrade = true;
   if(dayOfWeek == 5 && TradeOnFriday) shouldTrade = true;
   
   if(!shouldTrade) return;
   
   // Calculate ORB
   CalculateORB();
   
   // Check for trade signals
   if(orbCalculated && TimeCurrent() > orbEndTime)
   {
      CheckTradeSignals(dayOfWeek);
   }
   
   // Manage open positions
   ManagePositions(dayOfWeek);
   
   // Check session close
   CheckSessionClose();
}

//+------------------------------------------------------------------+
//| Calculate daily profit from closed deals                         |
//+------------------------------------------------------------------+
void CalculateDailyProfit()
{
   int currentDealsTotal = HistoryDealsTotal();
   
   // Only recalculate if new deals were added
   if(currentDealsTotal == lastDealsTotal) return;
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   datetime dayStart = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                    IntegerToString(timeStruct.mon) + "." + 
                                    IntegerToString(timeStruct.day) + " 00:00");
   
   HistorySelect(dayStart, TimeCurrent());
   
   dailyProfit = 0;
   for(int i = 0; i < HistoryDealsTotal(); i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0)
      {
         if(HistoryDealGetInteger(ticket, DEAL_MAGIC) == 123456 &&
            HistoryDealGetString(ticket, DEAL_SYMBOL) == _Symbol &&
            HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
         {
            dailyProfit += HistoryDealGetDouble(ticket, DEAL_PROFIT);
            dailyProfit += HistoryDealGetDouble(ticket, DEAL_SWAP);
            dailyProfit += HistoryDealGetDouble(ticket, DEAL_COMMISSION);
         }
      }
   }
   
   lastDealsTotal = currentDealsTotal;
}

//+------------------------------------------------------------------+
//| Calculate Opening Range                                          |
//+------------------------------------------------------------------+
void CalculateORB()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   // Set ORB start and end times
   datetime orbStart = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                    IntegerToString(timeStruct.mon) + "." + 
                                    IntegerToString(timeStruct.day) + " " +
                                    IntegerToString(ORB_StartHour) + ":" + 
                                    IntegerToString(ORB_StartMinute));
   
   datetime orbEnd = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                  IntegerToString(timeStruct.mon) + "." + 
                                  IntegerToString(timeStruct.day) + " " +
                                  IntegerToString(ORB_EndHour) + ":" + 
                                  IntegerToString(ORB_EndMinute));
   
   if(orbStartTime != orbStart)
   {
      orbStartTime = orbStart;
      orbEndTime = orbEnd;
      orbCalculated = false;
      orbMessagePrinted = false;
      orbHigh = 0;
      orbLow = 0;
   }
   
   // During ORB period, track high and low
   if(TimeCurrent() >= orbStartTime && TimeCurrent() <= orbEndTime)
   {
      double high = iHigh(_Symbol, PERIOD_CURRENT, 0);
      double low = iLow(_Symbol, PERIOD_CURRENT, 0);
      
      if(orbHigh == 0 || high > orbHigh) orbHigh = high;
      if(orbLow == 0 || low < orbLow) orbLow = low;
   }
   
   // After ORB period, validate ORB size
   if(TimeCurrent() > orbEndTime && !orbCalculated && orbHigh > 0 && orbLow > 0)
   {
      double orbSize = (orbHigh - orbLow) / orbLow * 100.0;
      
      int dayOfWeek = timeStruct.day_of_week;
      double minSize = 0.0;
      double maxSize = 0.5;
      
      switch(dayOfWeek)
      {
         case 1: minSize = Monday_MinORBSize; maxSize = Monday_MaxORBSize; break;
         case 2: minSize = Tuesday_MinORBSize; maxSize = Tuesday_MaxORBSize; break;
         case 3: minSize = Wednesday_MinORBSize; maxSize = Wednesday_MaxORBSize; break;
         case 4: minSize = Thursday_MinORBSize; maxSize = Thursday_MaxORBSize; break;
         case 5: minSize = Friday_MinORBSize; maxSize = Friday_MaxORBSize; break;
         default: return;
      }
      
      if(orbSize >= minSize && orbSize <= maxSize)
      {
         orbCalculated = true;
         if(!orbMessagePrinted)
         {
            Print("ORB calculated - High: ", orbHigh, " Low: ", orbLow, " Size: ", orbSize, "%");
            orbMessagePrinted = true;
         }
      }
      else
      {
         if(!orbMessagePrinted)
         {
            Print("ORB size out of range: ", orbSize, "% (min: ", minSize, "%, max: ", maxSize, "%)");
            orbMessagePrinted = true;
         }
         orbCalculated = false;
      }
   }
}

//+------------------------------------------------------------------+
//| Check for trade signals                                          |
//+------------------------------------------------------------------+
void CheckTradeSignals(int dayOfWeek)
{
   if(PositionsTotal() > 0) return; // Already in a trade
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double orbRange = orbHigh - orbLow;
   
   // Get day-specific settings
   bool tradeBreakout = false;
   bool tradeBreakdown = false;
   double profitTarget = 50.0;
   double stopLoss = 100.0;
   
   switch(dayOfWeek)
   {
      case 1:
         tradeBreakout = Monday_TradeBreakout;
         tradeBreakdown = Monday_TradeBreakdown;
         profitTarget = Monday_ProfitTarget;
         stopLoss = Monday_StopLoss;
         break;
      case 2:
         tradeBreakout = Tuesday_TradeBreakout;
         tradeBreakdown = Tuesday_TradeBreakdown;
         profitTarget = Tuesday_ProfitTarget;
         stopLoss = Tuesday_StopLoss;
         break;
      case 3:
         tradeBreakout = Wednesday_TradeBreakout;
         tradeBreakdown = Wednesday_TradeBreakdown;
         profitTarget = Wednesday_ProfitTarget;
         stopLoss = Wednesday_StopLoss;
         break;
      case 4:
         tradeBreakout = Thursday_TradeBreakout;
         tradeBreakdown = Thursday_TradeBreakdown;
         profitTarget = Thursday_ProfitTarget;
         stopLoss = Thursday_StopLoss;
         break;
      case 5:
         tradeBreakout = Friday_TradeBreakout;
         tradeBreakdown = Friday_TradeBreakdown;
         profitTarget = Friday_ProfitTarget;
         stopLoss = Friday_StopLoss;
         break;
      default:
         return;
   }
   
   // Check for breakout (buy signal)
   if(tradeBreakout && !breakoutTradeOpened && currentPrice > orbHigh)
   {
      double tp = NormalizeDouble(orbHigh + (orbRange * profitTarget / 100.0), _Digits);
      double sl = NormalizeDouble(orbHigh - (orbRange * stopLoss / 100.0), _Digits);
      
      ulong ticket = OpenTrade(ORDER_TYPE_BUY, orbHigh, sl, tp, dayOfWeek);
      if(ticket > 0)
      {
         breakoutTradeOpened = true;
      }
   }
   
   // Check for breakdown (sell signal)
   if(tradeBreakdown && !breakdownTradeOpened && currentPrice < orbLow)
   {
      double tp = NormalizeDouble(orbLow - (orbRange * profitTarget / 100.0), _Digits);
      double sl = NormalizeDouble(orbLow + (orbRange * stopLoss / 100.0), _Digits);
      
      ulong ticket = OpenTrade(ORDER_TYPE_SELL, orbLow, sl, tp, dayOfWeek);
      if(ticket > 0)
      {
         breakdownTradeOpened = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Open a trade                                                     |
//+------------------------------------------------------------------+
ulong OpenTrade(ENUM_ORDER_TYPE orderType, double entry, double sl, double tp, int dayOfWeek)
{
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = NormalizeDouble(LotSize, 2);
   request.type = orderType;
   request.price = NormalizeDouble((orderType == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID), _Digits);
   request.deviation = 10;
   request.magic = 123456;
   request.comment = "ORB Strategy";
   
   // Set TP/SL based on virtual mode
   if(!UseVirtualTPSL)
   {
      request.sl = NormalizeDouble(sl, _Digits);
      request.tp = NormalizeDouble(tp, _Digits);
   }
   
   // Determine supported filling mode
   int filling = (int)SymbolInfoInteger(_Symbol, SYMBOL_FILLING_MODE);
   
   if((filling & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC)
      request.type_filling = ORDER_FILLING_IOC;
   else if((filling & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK)
      request.type_filling = ORDER_FILLING_FOK;
   else
      request.type_filling = ORDER_FILLING_RETURN;
   
   // Send order
   bool success = OrderSend(request, result);
   
   // If filling mode error, try alternatives
   if(!success && result.retcode == 10030)
   {
      if(request.type_filling != ORDER_FILLING_IOC && (filling & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC)
      {
         request.type_filling = ORDER_FILLING_IOC;
         success = OrderSend(request, result);
      }
      
      if(!success && request.type_filling != ORDER_FILLING_FOK && (filling & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK)
      {
         request.type_filling = ORDER_FILLING_FOK;
         success = OrderSend(request, result);
      }
      
      if(!success && request.type_filling != ORDER_FILLING_RETURN)
      {
         request.type_filling = ORDER_FILLING_RETURN;
         success = OrderSend(request, result);
      }
   }
   
   if(result.retcode == 10009 || result.retcode == 10008) // Trade successful
   {
      Print("Trade opened: ", EnumToString(orderType), " at ", request.price, " SL: ", sl, " TP: ", tp);
      
      // Store virtual TP/SL if enabled
      if(UseVirtualTPSL && result.order > 0)
      {
         // Get trigger and target percentages for trailing stop
         bool activateMoveStop;
         double triggerPercent, targetPercent;
         
         switch(dayOfWeek)
         {
            case 1:
               activateMoveStop = Monday_ActivateMoveStop;
               triggerPercent = Monday_TriggerPercent;
               targetPercent = Monday_TargetPercent;
               break;
            case 2:
               activateMoveStop = Tuesday_ActivateMoveStop;
               triggerPercent = Tuesday_TriggerPercent;
               targetPercent = Tuesday_TargetPercent;
               break;
            case 3:
               activateMoveStop = Wednesday_ActivateMoveStop;
               triggerPercent = Wednesday_TriggerPercent;
               targetPercent = Wednesday_TargetPercent;
               break;
            case 4:
               activateMoveStop = Thursday_ActivateMoveStop;
               triggerPercent = Thursday_TriggerPercent;
               targetPercent = Thursday_TargetPercent;
               break;
            case 5:
               activateMoveStop = Friday_ActivateMoveStop;
               triggerPercent = Friday_TriggerPercent;
               targetPercent = Friday_TargetPercent;
               break;
            default:
               activateMoveStop = false;
               triggerPercent = 85.0;
               targetPercent = 20.0;
         }
         
         // Find the position ticket
         for(int i = 0; i < PositionsTotal(); i++)
         {
            ulong ticket = PositionGetTicket(i);
            if(PositionGetInteger(POSITION_MAGIC) == 123456 && PositionGetString(POSITION_SYMBOL) == _Symbol)
            {
               int size = ArraySize(virtualPositions);
               ArrayResize(virtualPositions, size + 1);
               virtualPositions[size].ticket = ticket;
               virtualPositions[size].virtualTP = tp;
               virtualPositions[size].virtualSL = sl;
               virtualPositions[size].trailingActivated = false;
               
               if(activateMoveStop)
               {
                  double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                  double targetDistance = MathAbs(tp - openPrice);
                  virtualPositions[size].triggerPrice = openPrice + (orderType == ORDER_TYPE_BUY ? 1 : -1) * (targetDistance * triggerPercent / 100.0);
               }
               break;
            }
         }
      }
      
      return result.order;
   }
   else
   {
      Print("Trade failed: ", result.retcode, " - ", result.comment);
      return 0;
   }
}

//+------------------------------------------------------------------+
//| Manage open positions with trailing stop                         |
//+------------------------------------------------------------------+
void ManagePositions(int dayOfWeek)
{
   // Handle virtual TP/SL
   if(UseVirtualTPSL)
   {
      CheckVirtualTPSL(dayOfWeek);
      return;
   }
   
   // Original broker TP/SL management
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != 123456) continue;
      
      double positionOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      
      // Get day-specific trailing stop settings
      bool activateMoveStop = false;
      double triggerPercent = 85.0;
      double targetPercent = 20.0;
      
      switch(dayOfWeek)
      {
         case 1:
            activateMoveStop = Monday_ActivateMoveStop;
            triggerPercent = Monday_TriggerPercent;
            targetPercent = Monday_TargetPercent;
            break;
         case 2:
            activateMoveStop = Tuesday_ActivateMoveStop;
            triggerPercent = Tuesday_TriggerPercent;
            targetPercent = Tuesday_TargetPercent;
            break;
         case 3:
            activateMoveStop = Wednesday_ActivateMoveStop;
            triggerPercent = Wednesday_TriggerPercent;
            targetPercent = Wednesday_TargetPercent;
            break;
         case 4:
            activateMoveStop = Thursday_ActivateMoveStop;
            triggerPercent = Thursday_TriggerPercent;
            targetPercent = Thursday_TargetPercent;
            break;
         case 5:
            activateMoveStop = Friday_ActivateMoveStop;
            triggerPercent = Friday_TriggerPercent;
            targetPercent = Friday_TargetPercent;
            break;
         default:
            continue;
      }
      
      if(!activateMoveStop) continue;
      
      double currentPrice = (posType == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double orbRange = orbHigh - orbLow;
      
      // Calculate trigger and target levels
      if(posType == POSITION_TYPE_BUY)
      {
         double targetDistance = currentTP - positionOpenPrice;
         double triggerPrice = NormalizeDouble(positionOpenPrice + (targetDistance * triggerPercent / 100.0), _Digits);
         double newSL = NormalizeDouble(positionOpenPrice + (orbRange * targetPercent / 100.0), _Digits);
         
         // Move stop to lock in profit when trigger is reached
         if(currentPrice >= triggerPrice && newSL > currentSL)
         {
            ModifyPosition(ticket, newSL, currentTP);
            Print("Trailing stop activated for BUY position. New SL: ", newSL);
         }
      }
      else if(posType == POSITION_TYPE_SELL)
      {
         double targetDistance = positionOpenPrice - currentTP;
         double triggerPrice = NormalizeDouble(positionOpenPrice - (targetDistance * triggerPercent / 100.0), _Digits);
         double newSL = NormalizeDouble(positionOpenPrice - (orbRange * targetPercent / 100.0), _Digits);
         
         // Move stop to lock in profit when trigger is reached
         if(currentPrice <= triggerPrice && (currentSL == 0 || newSL < currentSL))
         {
            ModifyPosition(ticket, newSL, currentTP);
            Print("Trailing stop activated for SELL position. New SL: ", newSL);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Check virtual TP/SL on each tick                                 |
//+------------------------------------------------------------------+
void CheckVirtualTPSL(int dayOfWeek)
{
   for(int i = ArraySize(virtualPositions) - 1; i >= 0; i--)
   {
      ulong ticket = virtualPositions[i].ticket;
      
      if(!PositionSelectByTicket(ticket))
      {
         // Position closed, remove from array
         ArrayRemove(virtualPositions, i, 1);
         continue;
      }
      
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double currentPrice = (posType == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      
      // Check virtual TP
      if((posType == POSITION_TYPE_BUY && currentPrice >= virtualPositions[i].virtualTP) ||
         (posType == POSITION_TYPE_SELL && currentPrice <= virtualPositions[i].virtualTP))
      {
         Print("Virtual TP hit at ", currentPrice);
         ClosePosition(ticket);
         ArrayRemove(virtualPositions, i, 1);
         continue;
      }
      
      // Check virtual SL
      if((posType == POSITION_TYPE_BUY && currentPrice <= virtualPositions[i].virtualSL) ||
         (posType == POSITION_TYPE_SELL && currentPrice >= virtualPositions[i].virtualSL))
      {
         Print("Virtual SL hit at ", currentPrice);
         ClosePosition(ticket);
         ArrayRemove(virtualPositions, i, 1);
         continue;
      }
      
      // Check trailing stop trigger
      if(!virtualPositions[i].trailingActivated && virtualPositions[i].triggerPrice > 0)
      {
         bool triggerHit = false;
         
         if(posType == POSITION_TYPE_BUY && currentPrice >= virtualPositions[i].triggerPrice)
            triggerHit = true;
         else if(posType == POSITION_TYPE_SELL && currentPrice <= virtualPositions[i].triggerPrice)
            triggerHit = true;
         
         if(triggerHit)
         {
            // Get target percent for this day
            double targetPercent = 20.0;
            switch(dayOfWeek)
            {
               case 1: targetPercent = Monday_TargetPercent; break;
               case 2: targetPercent = Tuesday_TargetPercent; break;
               case 3: targetPercent = Wednesday_TargetPercent; break;
               case 4: targetPercent = Thursday_TargetPercent; break;
               case 5: targetPercent = Friday_TargetPercent; break;
            }
            
            double orbRange = orbHigh - orbLow;
            double newSL = NormalizeDouble(openPrice + (posType == POSITION_TYPE_BUY ? 1 : -1) * (orbRange * targetPercent / 100.0), _Digits);
            
            virtualPositions[i].virtualSL = newSL;
            virtualPositions[i].trailingActivated = true;
            Print("Virtual trailing stop activated. New SL: ", newSL);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Modify position SL/TP                                            |
//+------------------------------------------------------------------+
bool ModifyPosition(ulong ticket, double sl, double tp)
{
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   request.action = TRADE_ACTION_SLTP;
   request.position = ticket;
   request.sl = NormalizeDouble(sl, _Digits);
   request.tp = NormalizeDouble(tp, _Digits);
   
   if(OrderSend(request, result))
   {
      return true;
   }
   else
   {
      Print("Modify failed: ", result.retcode);
      return false;
   }
}

//+------------------------------------------------------------------+
//| Check and close positions at session close                       |
//+------------------------------------------------------------------+
void CheckSessionClose()
{
   if(sessionClosed) return; // Already closed positions today
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   // Calculate session close time
   datetime sessionClose = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                        IntegerToString(timeStruct.mon) + "." + 
                                        IntegerToString(timeStruct.day) + " " +
                                        IntegerToString(SessionEndHour) + ":" + 
                                        IntegerToString(SessionEndMinute));
   
   // Close all positions at session close
   if(TimeCurrent() >= sessionClose)
   {
      int closedCount = 0;
      
      // Close all open positions
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket <= 0) continue;
         
         if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
         if(PositionGetInteger(POSITION_MAGIC) != 123456) continue;
         
         if(ClosePosition(ticket))
         {
            closedCount++;
         }
      }
      
      // Clear virtual positions array
      if(UseVirtualTPSL)
      {
         ArrayResize(virtualPositions, 0);
      }
      
      if(closedCount > 0)
      {
         Print("Session closed - ", closedCount, " position(s) closed at ", TimeToString(TimeCurrent()));
      }
      
      sessionClosed = true;
   }
}

//+------------------------------------------------------------------+
//| Close a position                                                 |
//+------------------------------------------------------------------+
bool ClosePosition(ulong ticket)
{
   // Check if position still exists
   if(!PositionSelectByTicket(ticket)) return false;
   
   // Verify it's our position
   if(PositionGetInteger(POSITION_MAGIC) != 123456) return false;
   if(PositionGetString(POSITION_SYMBOL) != _Symbol) return false;
   
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   request.action = TRADE_ACTION_DEAL;
   request.position = ticket;
   request.symbol = PositionGetString(POSITION_SYMBOL);
   request.volume = NormalizeDouble(PositionGetDouble(POSITION_VOLUME), 2);
   request.type = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
   request.price = NormalizeDouble((request.type == ORDER_TYPE_SELL) ? SymbolInfoDouble(request.symbol, SYMBOL_BID) : SymbolInfoDouble(request.symbol, SYMBOL_ASK), _Digits);
   request.deviation = 10;
   request.magic = 123456;
   
   // Determine supported filling mode
   int filling = (int)SymbolInfoInteger(request.symbol, SYMBOL_FILLING_MODE);
   
   if((filling & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC)
      request.type_filling = ORDER_FILLING_IOC;
   else if((filling & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK)
      request.type_filling = ORDER_FILLING_FOK;
   else
      request.type_filling = ORDER_FILLING_RETURN;
   
   // Send order
   bool success = OrderSend(request, result);
   
   // If filling mode error, try alternatives
   if(!success && result.retcode == 10030)
   {
      if(request.type_filling != ORDER_FILLING_IOC && (filling & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC)
      {
         request.type_filling = ORDER_FILLING_IOC;
         success = OrderSend(request, result);
      }
      
      if(!success && request.type_filling != ORDER_FILLING_FOK && (filling & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK)
      {
         request.type_filling = ORDER_FILLING_FOK;
         success = OrderSend(request, result);
      }
      
      if(!success && request.type_filling != ORDER_FILLING_RETURN)
      {
         request.type_filling = ORDER_FILLING_RETURN;
         success = OrderSend(request, result);
      }
   }
   
   if(result.retcode == 10009 || result.retcode == 10008)
   {
      Print("Position closed at session close: ", ticket);
      return true;
   }
   else
   {
      Print("Close failed: ", result.retcode);
      return false;
   }
}
//+------------------------------------------------------------------+
