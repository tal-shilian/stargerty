//@version=5
strategy("IB Breakout Strategy - NQ", 
         overlay=true, 
         initial_capital=50000,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=100,
         commission_type=strategy.commission.percent,
         commission_value=0.04,
         slippage=2)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================

// Initial Balance Settings
ibStartHour = input.int(9, "IB Start Hour (ET)", minval=0, maxval=23, group="Initial Balance")
ibStartMinute = input.int(30, "IB Start Minute", minval=0, maxval=59, group="Initial Balance")
ibDurationMinutes = input.int(60, "IB Duration (minutes)", minval=15, maxval=120, group="Initial Balance")

// Trading Session
sessionStartHour = input.int(9, "Session Start Hour (ET)", minval=0, maxval=23, group="Trading Session")
sessionStartMinute = input.int(30, "Session Start Minute", minval=0, maxval=59, group="Trading Session")
sessionEndHour = input.int(16, "Session End Hour (ET)", minval=0, maxval=23, group="Trading Session")
sessionEndMinute = input.int(0, "Session End Minute", minval=0, maxval=59, group="Trading Session")

// Breakout Settings
breakoutByWick = input.bool(true, "Breakout by Wick (vs Body)", group="Breakout Settings", tooltip="Use wick for breakout detection instead of candle body")
waitForClose = input.bool(false, "Wait for Candle Close", group="Breakout Settings")
ibSizeFilter = input.string("Any Size", "IB Size Filter", options=["Any Size", "Minimum Points"], group="Breakout Settings")
minIBSize = input.float(20, "Minimum IB Size (points)", minval=1, step=5, group="Breakout Settings")

// Risk Management
useStopLoss = input.bool(true, "Use Stop Loss", group="Risk Management")
stopLossPoints = input.float(50, "Stop Loss (points)", minval=1, step=5, group="Risk Management")
useTakeProfit = input.bool(true, "Use Take Profit", group="Risk Management")
takeProfitPoints = input.float(100, "Take Profit (points)", minval=1, step=10, group="Risk Management")
trailStop = input.bool(false, "Use Trailing Stop", group="Risk Management")
trailStopPoints = input.float(30, "Trailing Stop (points)", minval=1, step=5, group="Risk Management")

// Trading Days
tradeMonday = input.bool(true, "Monday", group="Trading Days", inline="days1")
tradeTuesday = input.bool(true, "Tuesday", group="Trading Days", inline="days1")
tradeWednesday = input.bool(true, "Wednesday", group="Trading Days", inline="days2")
tradeThursday = input.bool(true, "Thursday", group="Trading Days", inline="days2")
tradeFriday = input.bool(true, "Friday", group="Trading Days", inline="days3")

// Visual Settings
showIBBox = input.bool(true, "Show IB Box", group="Visuals")
showBreakoutLabels = input.bool(true, "Show Breakout Labels", group="Visuals")
showDebugTable = input.bool(true, "Show Debug Table", group="Visuals")

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if current day is a trading day
isTradingDay() =>
    dayOfWeek = dayofweek(time)
    (dayOfWeek == dayofweek.monday and tradeMonday) or
     (dayOfWeek == dayofweek.tuesday and tradeTuesday) or
     (dayOfWeek == dayofweek.wednesday and tradeWednesday) or
     (dayOfWeek == dayofweek.thursday and tradeThursday) or
     (dayOfWeek == dayofweek.friday and tradeFriday)

// Convert time to minutes since midnight
timeToMinutes(h, m) =>
    h * 60 + m

// Check if current time is within a time range
isInTimeRange(startH, startM, endH, endM) =>
    currentMinutes = timeToMinutes(hour(time), minute(time))
    startMinutes = timeToMinutes(startH, startM)
    endMinutes = timeToMinutes(endH, endM)
    currentMinutes >= startMinutes and currentMinutes < endMinutes

// ============================================================================
// STATE VARIABLES
// ============================================================================

var float ibHigh = na
var float ibLow = na
var bool ibFormed = false
var bool firstBreakHighTaken = false
var bool firstBreakLowTaken = false
var int ibStartBar = na
var int ibEndBar = na

// ============================================================================
// INITIAL BALANCE CALCULATION
// ============================================================================

// Calculate IB end time
ibEndHour = ibStartHour
ibEndMinute = ibStartMinute + ibDurationMinutes
if ibEndMinute >= 60
    ibEndHour := ibEndHour + math.floor(ibEndMinute / 60)
    ibEndMinute := ibEndMinute % 60

isInIBPeriod = isInTimeRange(ibStartHour, ibStartMinute, ibEndHour, ibEndMinute)
isInTradingSession = isInTimeRange(sessionStartHour, sessionStartMinute, sessionEndHour, sessionEndMinute)

// Reset on new day
if ta.change(time("D")) != 0
    ibHigh := na
    ibLow := na
    ibFormed := false
    firstBreakHighTaken := false
    firstBreakLowTaken := false
    ibStartBar := na
    ibEndBar := na

// Capture IB start bar
if isInIBPeriod and na(ibStartBar) and isTradingDay()
    ibStartBar := bar_index

// Build Initial Balance
if isInIBPeriod and isTradingDay()
    if na(ibHigh) or high > ibHigh
        ibHigh := high
    if na(ibLow) or low < ibLow
        ibLow := low

// Mark IB as formed when period ends
if not isInIBPeriod and not na(ibHigh) and not na(ibLow) and not ibFormed
    // Check IB size filter
    ibSize = ibHigh - ibLow
    if ibSizeFilter == "Any Size" or ibSize >= minIBSize
        ibFormed := true
        ibEndBar := bar_index

// ============================================================================
// BREAKOUT DETECTION
// ============================================================================

// Determine breakout price (wick vs body)
breakoutHigh = breakoutByWick ? high : close
breakoutLow = breakoutByWick ? low : close

// Detect first break of IB high
breakIBHigh = false
if ibFormed and not firstBreakHighTaken and isInTradingSession and isTradingDay()
    if waitForClose
        breakIBHigh := close > ibHigh
    else
        breakIBHigh := breakoutHigh > ibHigh

// Detect first break of IB low
breakIBLow = false
if ibFormed and not firstBreakLowTaken and isInTradingSession and isTradingDay()
    if waitForClose
        breakIBLow := close < ibLow
    else
        breakIBLow := breakoutLow < ibLow

// ============================================================================
// ENTRY LOGIC
// ============================================================================

// Long Entry (Break IB High)
if breakIBHigh and strategy.position_size == 0
    entryPrice = close
    stopPrice = useStopLoss ? entryPrice - stopLossPoints : na
    targetPrice = useTakeProfit ? entryPrice + takeProfitPoints : na
    
    strategy.entry("Long", strategy.long)
    
    if useStopLoss and useTakeProfit
        if trailStop
            strategy.exit("Exit Long", "Long", stop=stopPrice, limit=targetPrice, trail_points=trailStopPoints)
        else
            strategy.exit("Exit Long", "Long", stop=stopPrice, limit=targetPrice)
    else if useStopLoss
        if trailStop
            strategy.exit("Exit Long", "Long", stop=stopPrice, trail_points=trailStopPoints)
        else
            strategy.exit("Exit Long", "Long", stop=stopPrice)
    else if useTakeProfit
        strategy.exit("Exit Long", "Long", limit=targetPrice)
    
    firstBreakHighTaken := true
    
    if showBreakoutLabels
        label.new(bar_index, low, "LONG\nBreak IB High", 
                 style=label.style_label_up, color=color.new(color.green, 0), 
                 textcolor=color.white, size=size.normal)

// Short Entry (Break IB Low)
if breakIBLow and strategy.position_size == 0
    entryPrice = close
    stopPrice = useStopLoss ? entryPrice + stopLossPoints : na
    targetPrice = useTakeProfit ? entryPrice - takeProfitPoints : na
    
    strategy.entry("Short", strategy.short)
    
    if useStopLoss and useTakeProfit
        if trailStop
            strategy.exit("Exit Short", "Short", stop=stopPrice, limit=targetPrice, trail_points=trailStopPoints)
        else
            strategy.exit("Exit Short", "Short", stop=stopPrice, limit=targetPrice)
    else if useStopLoss
        if trailStop
            strategy.exit("Exit Short", "Short", stop=stopPrice, trail_points=trailStopPoints)
        else
            strategy.exit("Exit Short", "Short", stop=stopPrice)
    else if useTakeProfit
        strategy.exit("Exit Short", "Short", limit=targetPrice)
    
    firstBreakLowTaken := true
    
    if showBreakoutLabels
        label.new(bar_index, high, "SHORT\nBreak IB Low", 
                 style=label.style_label_down, color=color.new(color.red, 0), 
                 textcolor=color.white, size=size.normal)

// Close positions at end of session
if not isInTradingSession and strategy.position_size != 0
    strategy.close_all("Session End")

// ============================================================================
// VISUALIZATION
// ============================================================================

// Draw IB Box
if showIBBox and ibFormed and not na(ibStartBar) and not na(ibEndBar)
    box.new(ibStartBar, ibHigh, ibEndBar, ibLow, 
           border_color=color.new(color.blue, 0),
           bgcolor=color.new(color.blue, 90), 
           border_width=2,
           extend=extend.right)

// Plot IB levels
plot(ibFormed ? ibHigh : na, "IB High", color=color.new(color.green, 30), linewidth=2, style=plot.style_linebr)
plot(ibFormed ? ibLow : na, "IB Low", color=color.new(color.red, 30), linewidth=2, style=plot.style_linebr)

// Background colors
bgcolor(isInIBPeriod ? color.new(color.blue, 95) : na, title="IB Period")
bgcolor(isInTradingSession and ibFormed ? color.new(color.yellow, 97) : na, title="Trading Session")

// Debug Table
if showDebugTable
    var table debugTable = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 85), border_width=1)
    if barstate.islast
        table.cell(debugTable, 0, 0, "Metric", text_color=color.white, bgcolor=color.new(color.gray, 60))
        table.cell(debugTable, 1, 0, "Value", text_color=color.white, bgcolor=color.new(color.gray, 60))
        
        table.cell(debugTable, 0, 1, "IB High", text_color=color.white)
        table.cell(debugTable, 1, 1, na(ibHigh) ? "N/A" : str.tostring(ibHigh, format.mintick), 
                   text_color=na(ibHigh) ? color.gray : color.green)
        
        table.cell(debugTable, 0, 2, "IB Low", text_color=color.white)
        table.cell(debugTable, 1, 2, na(ibLow) ? "N/A" : str.tostring(ibLow, format.mintick), 
                   text_color=na(ibLow) ? color.gray : color.red)
        
        ibSizeValue = na(ibHigh) or na(ibLow) ? na : ibHigh - ibLow
        table.cell(debugTable, 0, 3, "IB Size", text_color=color.white)
        table.cell(debugTable, 1, 3, na(ibSizeValue) ? "N/A" : str.tostring(ibSizeValue, format.mintick) + " pts", 
                   text_color=na(ibSizeValue) ? color.gray : color.yellow)
        
        table.cell(debugTable, 0, 4, "IB Formed", text_color=color.white)
        table.cell(debugTable, 1, 4, ibFormed ? "YES" : "NO", 
                   text_color=ibFormed ? color.green : color.gray)
        
        table.cell(debugTable, 0, 5, "Break High", text_color=color.@white)
        table.cell(debugTable, 1, 5, firstBreakHighTaken ? "YES" : "NO", 
                   text_color=firstBreakHighTaken ? color.orange : color.gray)
        
        table.cell(debugTable, 0, 6, "Break Low", text_color=color.white)
        table.cell(debugTable, 1, 6, firstBreakLowTaken ? "YES" : "NO", 
                   text_color=firstBreakLowTaken ? color.orange : color.gray)
        
        table.cell(debugTable, 0, 7, "Current Time", text_color=color.white)
        table.cell(debugTable, 1, 7, str.format("{0,number,00}:{1,number,00}", hour(time), minute(time)), 
                   text_color=color.yellow)

// Plot breakout signals
plotchar(breakIBHigh, "Break IB High", "▲", location.belowbar, color.green, size=size.small)
plotchar(breakIBLow, "Break IB Low", "▼", location.abovebar, color.red, size=size.small)