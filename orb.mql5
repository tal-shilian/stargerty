//+------------------------------------------------------------------+
//|                                                          orb.mql5 |
//|                                    Opening Range Breakout Strategy |
//+------------------------------------------------------------------+
#property copyright "ORB Strategy"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

//--- Enums
enum ENUM_PROFIT_TARGET
{
   PT_30 = 30,    // 30%
   PT_35 = 35,    // 35%
   PT_40 = 40,    // 40%
   PT_45 = 45,    // 45%
   PT_50 = 50,    // 50%
   PT_55 = 55,    // 55%
   PT_60 = 60,    // 60%
   PT_65 = 65,    // 65%
   PT_70 = 70,    // 70%
   PT_75 = 75,    // 75%
   PT_80 = 80,    // 80%
   PT_85 = 85,    // 85%
   PT_90 = 90,    // 90%
   PT_95 = 95,    // 95%
   PT_100 = 100   // 100%
};

enum ENUM_STOP_LOSS
{
   SL_30 = 30,    // 30%
   SL_35 = 35,    // 35%
   SL_40 = 40,    // 40%
   SL_45 = 45,    // 45%
   SL_50 = 50,    // 50%
   SL_55 = 55,    // 55%
   SL_60 = 60,    // 60%
   SL_65 = 65,    // 65%
   SL_70 = 70,    // 70%
   SL_75 = 75,    // 75%
   SL_80 = 80,    // 80%
   SL_85 = 85,    // 85%
   SL_90 = 90,    // 90%
   SL_95 = 95,    // 95%
   SL_100 = 100   // 100%
};

//--- Input Parameters
input group "=== Range Settings ==="
input int InpRangeMinutes = 15;              // Opening Range Duration (minutes)
input ENUM_TIMEFRAMES InpCandleTimeframe = PERIOD_M15;  // Candle Timeframe for Entry
input int InpMaxTradesPerDay = 1;            // Max Trades Per Day

input group "=== MONDAY ==="
input bool InpTradeMonday = true;                        // Trade on Monday
input bool InpMondayBreakout = true;                     // Trade ORB breakout
input bool InpMondayBreakdown = true;                    // Trade ORB breakdown
input ENUM_PROFIT_TARGET InpMondayProfitTarget = PT_50;  // Profit target (% of ORB size)
input ENUM_STOP_LOSS InpMondayStopLoss = SL_100;         // Stop loss (% of ORB size)
input double InpMondayMinORBSize = 0.0;                  // Min ORB size %
input double InpMondayMaxORBSize = 0.6;                  // Max ORB size %

input group "=== TUESDAY ==="
input bool InpTradeTuesday = true;                        // Trade on Tuesday
input bool InpTuesdayBreakout = true;                     // Trade ORB breakout
input bool InpTuesdayBreakdown = true;                    // Trade ORB breakdown
input ENUM_PROFIT_TARGET InpTuesdayProfitTarget = PT_50;  // Profit target (% of ORB size)
input ENUM_STOP_LOSS InpTuesdayStopLoss = SL_100;         // Stop loss (% of ORB size)
input double InpTuesdayMinORBSize = 0.0;                  // Min ORB size %
input double InpTuesdayMaxORBSize = 0.6;                  // Max ORB size %

input group "=== WEDNESDAY ==="
input bool InpTradeWednesday = true;                        // Trade on Wednesday
input bool InpWednesdayBreakout = true;                     // Trade ORB breakout
input bool InpWednesdayBreakdown = true;                    // Trade ORB breakdown
input ENUM_PROFIT_TARGET InpWednesdayProfitTarget = PT_50;  // Profit target (% of ORB size)
input ENUM_STOP_LOSS InpWednesdayStopLoss = SL_100;         // Stop loss (% of ORB size)
input double InpWednesdayMinORBSize = 0.0;                  // Min ORB size %
input double InpWednesdayMaxORBSize = 0.6;                  // Max ORB size %

input group "=== THURSDAY ==="
input bool InpTradeThursday = true;                        // Trade on Thursday
input bool InpThursdayBreakout = true;                     // Trade ORB breakout
input bool InpThursdayBreakdown = true;                    // Trade ORB breakdown
input ENUM_PROFIT_TARGET InpThursdayProfitTarget = PT_50;  // Profit target (% of ORB size)
input ENUM_STOP_LOSS InpThursdayStopLoss = SL_100;         // Stop loss (% of ORB size)
input double InpThursdayMinORBSize = 0.0;                  // Min ORB size %
input double InpThursdayMaxORBSize = 0.6;                  // Max ORB size %

input group "=== FRIDAY ==="
input bool InpTradeFriday = true;                        // Trade on Friday
input bool InpFridayBreakout = true;                     // Trade ORB breakout
input bool InpFridayBreakdown = true;                    // Trade ORB breakdown
input ENUM_PROFIT_TARGET InpFridayProfitTarget = PT_50;  // Profit target (% of ORB size)
input ENUM_STOP_LOSS InpFridayStopLoss = SL_100;         // Stop loss (% of ORB size)
input double InpFridayMinORBSize = 0.0;                  // Min ORB size %
input double InpFridayMaxORBSize = 0.6;                  // Max ORB size %

input group "=== Filters ==="
input double InpMaxSpread = 10.0;            // Max Spread (points, 0=disabled)

input group "=== Risk Management ==="
input double InpRiskPercent = 1.0;           // Risk Per Trade (% of account)
input double InpMaxLossPerTrade = 0.0;       // Max Loss Per Trade (0=disabled, in account currency)
input double InpTP1Percent = 40.0;           // TP1 (% of ORB size)
input double InpTP1ClosePercent = 50.0;      // TP1 Close Size (% of position to close)
input double InpTP2Percent = 80.0;           // TP2 (% of ORB size)
input int InpMaxSlippagePoints = 10;         // Max Slippage (points)

input group "=== Time Settings ==="
input int InpStartHour = 9;                  // Market Open Hour
input int InpStartMinute = 30;               // Market Open Minute
input bool InpUseTimeBasedClose = true;      // Use Time-Based Position Close
input int InpCloseHour = 15;                 // Close All Positions Hour
input int InpCloseMinute = 45;               // Close All Positions Minute



//--- Global Variables
CTrade trade;
double rangeHigh = 0;
double rangeLow = 0;
bool rangeSet = false;
bool rangeRejected = false;  // Track if range was rejected
bool tradeTakenToday = false;
int tradesCountToday = 0;
datetime currentDay = 0;
datetime lastBarTime = 0;
int currentDayOfWeek = 0;

//--- Virtual Stop Loss tracking
struct VirtualSL
{
   ulong ticket;
   double slPrice;
   bool isLong;
};
VirtualSL virtualStops[];
int virtualStopsCount = 0;

//--- Partial TP tracking
struct PartialTP
{
   ulong ticket;
   double tp1Price;
   double closePercent;
   bool isLong;
   bool tp1Hit;
};
PartialTP partialTPs[];
int partialTPsCount = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(InpMaxSlippagePoints);
   trade.SetTypeFilling(ORDER_FILLING_FOK);
   
   // Print broker requirements
   long minStopLevel = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double minStopDistance = minStopLevel * point;
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   Print("=== BROKER REQUIREMENTS FOR ", _Symbol, " ===");
   Print("Minimum Stop Level: ", minStopLevel, " points");
   Print("Minimum Stop Distance: ", NormalizeDouble(minStopDistance, digits));
   Print("Point Size: ", point);
   Print("Digits: ", digits);
   Print("Min Lot: ", SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN));
   Print("Max Lot: ", SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX));
   Print("Lot Step: ", SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP));
   Print("==========================================");
   
   Print("ORB Strategy initialized successfully");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Cleanup
}

//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check virtual stop losses first
   CheckVirtualStopLosses();
   
   // Check partial take profits
   CheckPartialTakeProfits();
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   // Reset daily variables at start of new day
   if(timeStruct.day != currentDay)
   {
      rangeHigh = 0;
      rangeLow = 0;
      rangeSet = false;
      rangeRejected = false;
      tradeTakenToday = false;
      tradesCountToday = 0;
      lastBarTime = 0;
      currentDay = timeStruct.day;
      currentDayOfWeek = timeStruct.day_of_week;
      
      // Clear virtual stops for new day
      ArrayResize(virtualStops, 0);
      virtualStopsCount = 0;
      
      // Clear partial TPs for new day
      ArrayResize(partialTPs, 0);
      partialTPsCount = 0;
   }
   
   // Check if trading is allowed on this day
   if(!IsTradingDayAllowed(currentDayOfWeek))
      return;
   
   // Close all positions at end of day (if enabled)
   if(InpUseTimeBasedClose && timeStruct.hour == InpCloseHour && timeStruct.min >= InpCloseMinute)
   {
      CloseAllPositions();
      return;
   }
   
   // Set opening range
   if(!rangeSet && !rangeRejected)
   {
      SetOpeningRange(timeStruct);
      return;
   }
   
   // If range was rejected, skip trading for today
   if(rangeRejected)
      return;
   
   // Check if we can still take entries
   if(tradesCountToday >= InpMaxTradesPerDay)
      return;
   
   // Check for breakout
   CheckForBreakout();
}

//+------------------------------------------------------------------+
//| Set Opening Range                                                  |
//+------------------------------------------------------------------+
void SetOpeningRange(MqlDateTime &timeStruct)
{
   // Check if market has opened
   int minutesSinceOpen = GetMinutesSinceOpen(timeStruct);
   
   if(minutesSinceOpen < 0)
      return; // Market hasn't opened yet
   
   if(minutesSinceOpen >= InpRangeMinutes)
   {
      // Range period is over, calculate range
      if(rangeHigh == 0 && rangeLow == 0)
      {
         CalculateRange();
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Opening Range High and Low                               |
//+------------------------------------------------------------------+
void CalculateRange()
{
   datetime marketOpen = GetMarketOpenTime();
   datetime rangeEnd = marketOpen + InpRangeMinutes * 60;
   
   int bars = Bars(_Symbol, PERIOD_M1, marketOpen, rangeEnd);
   if(bars < InpRangeMinutes)
   {
      Print("Not enough bars to calculate range");
      return;
   }
   
   rangeHigh = 0;
   rangeLow = DBL_MAX;
   
   for(int i = 0; i < bars; i++)
   {
      datetime barTime = iTime(_Symbol, PERIOD_M1, i);
      if(barTime >= marketOpen && barTime < rangeEnd)
      {
         double high = iHigh(_Symbol, PERIOD_M1, i);
         double low = iLow(_Symbol, PERIOD_M1, i);
         
         if(high > rangeHigh) rangeHigh = high;
         if(low < rangeLow) rangeLow = low;
      }
   }
   
   if(rangeHigh > 0 && rangeLow < DBL_MAX)
   {
      // Check if range size is within acceptable limits
      if(!IsValidRangeSize(currentDayOfWeek))
      {
         Print("‚ùå Range rejected - Size outside limits (will not trade today)");
         rangeHigh = 0;
         rangeLow = 0;
         rangeRejected = true;  // Mark as rejected to avoid recalculation
         return;
      }
      
      rangeSet = true;
      double rangeSize = rangeHigh - rangeLow;
      double rangeSizePercent = (rangeSize / rangeHigh) * 100.0;
      
      int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
      
      // Truncate to 3 decimals without rounding
      double truncatedPercent = MathFloor(rangeSizePercent * 1000) / 1000;
      
      Print("Opening Range Set - High: ", DoubleToString(rangeHigh, digits), 
            " Low: ", DoubleToString(rangeLow, digits), 
            " Size: ", DoubleToString(rangeSize, digits), 
            " (", StringFormat("%.3f", truncatedPercent), "%)");
   }
}

//+------------------------------------------------------------------+
//| Get Minutes Since Market Open                                      |
//+------------------------------------------------------------------+
int GetMinutesSinceOpen(MqlDateTime &timeStruct)
{
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int openMinutes = InpStartHour * 60 + InpStartMinute;
   
   return currentMinutes - openMinutes;
}

//+------------------------------------------------------------------+
//| Get Market Open Time for Today                                     |
//+------------------------------------------------------------------+
datetime GetMarketOpenTime()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   timeStruct.hour = InpStartHour;
   timeStruct.min = InpStartMinute;
   timeStruct.sec = 0;
   
   return StructToTime(timeStruct);
}

//+------------------------------------------------------------------+
//| Calculate Max SL Distance Based on Max Loss                        |
//+------------------------------------------------------------------+
double CalculateMaxSLDistance(double maxLoss)
{
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   
   // Calculate max distance in price based on max loss amount
   // maxLoss = (slDistance / tickSize) * tickValue
   // slDistance = (maxLoss * tickSize) / tickValue
   double maxSlDistance = (maxLoss * tickSize) / tickValue;
   
   return maxSlDistance;
}

//+------------------------------------------------------------------+
//| Check for Breakout and Enter Trade                                 |
//+------------------------------------------------------------------+
void CheckForBreakout()
{
   // Check if new bar has formed on selected timeframe
   datetime currentBarTime = iTime(_Symbol, InpCandleTimeframe, 0);
   if(currentBarTime == lastBarTime)
      return; // Wait for bar to close
   
   lastBarTime = currentBarTime;
   
   // Get the closed bar data (bar index 1)
   double closedBarClose = iClose(_Symbol, InpCandleTimeframe, 1);
   double closedBarHigh = iHigh(_Symbol, InpCandleTimeframe, 1);
   double closedBarLow = iLow(_Symbol, InpCandleTimeframe, 1);
   
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   double rangeSize = rangeHigh - rangeLow;
   
   // Get day-specific settings
   bool tradeBreakout = GetBreakoutSetting(currentDayOfWeek);
   bool tradeBreakdown = GetBreakdownSetting(currentDayOfWeek);
   double profitTarget = GetProfitTarget(currentDayOfWeek);
   double stopLoss = GetStopLoss(currentDayOfWeek);
   
   // Check for bullish breakout - closed bar must close above range high
   if(closedBarClose > rangeHigh && tradeBreakout)
   {
      if(PassesFilters(true))
      {
         // Calculate TP based on ORB levels (before opening position)
         double tp1Offset = rangeSize * (InpTP1Percent / 100.0);
         double tp1 = NormalizeDouble(rangeHigh + tp1Offset, digits);
         
         double tp2Offset = rangeSize * (InpTP2Percent / 100.0);
         double tp2 = NormalizeDouble(rangeHigh + tp2Offset, digits);
         
         // Calculate initial SL for lot sizing (estimate)
         double slOffset = rangeSize * (stopLoss / 100.0);
         double estimatedSL = rangeLow - slOffset;
         double estimatedEntry = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double estimatedSlDistance = estimatedEntry - estimatedSL;
         
         // Calculate lot size based on estimated risk
         double lotSize = CalculateLotSize(estimatedSlDistance);
         
         // Ensure minimum lot size
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         if(lotSize < minLot) lotSize = minLot;
         
         // Open single position with TP2 (final target), then add SL
         string comment = "ORB Long " + TimeToString(TimeCurrent(), TIME_DATE);
         if(trade.Buy(lotSize, _Symbol, 0, 0, tp2, comment))
         {
            ulong ticket = trade.ResultOrder();
            
            // Get actual entry price
            if(PositionSelectByTicket(ticket))
            {
               double actualEntry = PositionGetDouble(POSITION_PRICE_OPEN);
               
               // Calculate SL based on actual entry price
               double sl = rangeLow - slOffset;
               
               // Check if max loss override is needed
               if(InpMaxLossPerTrade > 0)
               {
                  double maxSlDistance = CalculateMaxSLDistance(InpMaxLossPerTrade);
                  double currentSlDistance = actualEntry - sl;
                  if(currentSlDistance > maxSlDistance)
                  {
                     sl = actualEntry - maxSlDistance;
                     Print("SL adjusted by max loss limit - New SL: ", sl);
                  }
               }
               
               sl = NormalizeDouble(sl, digits);
               
               // Try to add SL to broker
               if(trade.PositionModify(ticket, sl, tp2))
               {
                  Print("‚úì Long opened - Entry: ", DoubleToString(actualEntry, digits), 
                        " SL: ", DoubleToString(sl, digits), 
                        " TP1: ", DoubleToString(tp1, digits), " (", InpTP1Percent, "%)", 
                        " TP2: ", DoubleToString(tp2, digits), " (", InpTP2Percent, "%)", 
                        " Lots: ", DoubleToString(lotSize, 2));
               }
               else
               {
                  Print("‚ö† Long opened but SL update failed - Adding Virtual SL - Entry: ", DoubleToString(actualEntry, digits), 
                        " TP2: ", DoubleToString(tp2, digits), 
                        " Lots: ", DoubleToString(lotSize, 2));
                  AddVirtualStopLoss(ticket, sl, true);
               }
               
               // Store ticket for partial TP monitoring
               MonitorPartialTP(ticket, tp1, InpTP1ClosePercent, true);
            }
         }
         
         tradesCountToday++;
         tradeTakenToday = true;
      }
   }
   // Check for bearish breakout - closed bar must close below range low
   else if(closedBarClose < rangeLow && tradeBreakdown)
   {
      if(PassesFilters(false))
      {
         // Calculate TP based on ORB levels (before opening position)
         double tp1Offset = rangeSize * (InpTP1Percent / 100.0);
         double tp1 = NormalizeDouble(rangeLow - tp1Offset, digits);
         
         double tp2Offset = rangeSize * (InpTP2Percent / 100.0);
         double tp2 = NormalizeDouble(rangeLow - tp2Offset, digits);
         
         // Calculate initial SL for lot sizing (estimate)
         double slOffset = rangeSize * (stopLoss / 100.0);
         double estimatedSL = rangeHigh + slOffset;
         double estimatedEntry = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double estimatedSlDistance = estimatedSL - estimatedEntry;
         
         // Calculate lot size based on estimated risk
         double lotSize = CalculateLotSize(estimatedSlDistance);
         
         // Ensure minimum lot size
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         if(lotSize < minLot) lotSize = minLot;
         
         // Open single position with TP2 (final target), then add SL
         string comment = "ORB Short " + TimeToString(TimeCurrent(), TIME_DATE);
         if(trade.Sell(lotSize, _Symbol, 0, 0, tp2, comment))
         {
            ulong ticket = trade.ResultOrder();
            
            // Get actual entry price
            if(PositionSelectByTicket(ticket))
            {
               double actualEntry = PositionGetDouble(POSITION_PRICE_OPEN);
               
               // Calculate SL based on actual entry price
               double sl = rangeHigh + slOffset;
               
               // Check if max loss override is needed
               if(InpMaxLossPerTrade > 0)
               {
                  double maxSlDistance = CalculateMaxSLDistance(InpMaxLossPerTrade);
                  double currentSlDistance = sl - actualEntry;
                  if(currentSlDistance > maxSlDistance)
                  {
                     sl = actualEntry + maxSlDistance;
                     Print("SL adjusted by max loss limit - New SL: ", sl);
                  }
               }
               
               sl = NormalizeDouble(sl, digits);
               
               // Try to add SL to broker
               if(trade.PositionModify(ticket, sl, tp2))
               {
                  Print("‚úì Short opened - Entry: ", DoubleToString(actualEntry, digits), 
                        " SL: ", DoubleToString(sl, digits), 
                        " TP1: ", DoubleToString(tp1, digits), " (", InpTP1Percent, "%)", 
                        " TP2: ", DoubleToString(tp2, digits), " (", InpTP2Percent, "%)", 
                        " Lots: ", DoubleToString(lotSize, 2));
               }
               else
               {
                  Print("‚ö† Short opened but SL update failed - Adding Virtual SL - Entry: ", DoubleToString(actualEntry, digits), 
                        " TP2: ", DoubleToString(tp2, digits), 
                        " Lots: ", DoubleToString(lotSize, 2));
                  AddVirtualStopLoss(ticket, sl, false);
               }
               
               // Store ticket for partial TP monitoring
               MonitorPartialTP(ticket, tp1, InpTP1ClosePercent, false);
            }
         }
         
         tradesCountToday++;
         tradeTakenToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size Based on Risk Percentage                        |
//+------------------------------------------------------------------+
double CalculateLotSize(double slDistance)
{
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * (InpRiskPercent / 100.0);
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // Calculate lot size based on risk
   double lotSize = (riskAmount / slDistance) / (tickValue / tickSize);
   
   // Normalize to lot step
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   
   // Ensure within broker limits
   if(lotSize < minLot) lotSize = minLot;
   if(lotSize > maxLot) lotSize = maxLot;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Check if Range Size is Valid                                       |
//+------------------------------------------------------------------+
bool IsValidRangeSize(int dayOfWeek)
{
   double rangeSize = rangeHigh - rangeLow;
   double rangeSizePercent = (rangeSize / rangeHigh) * 100.0;
   
   double minSize = GetMinORBSize(dayOfWeek);
   double maxSize = GetMaxORBSize(dayOfWeek);
   
   // Truncate to 3 decimals without rounding
   double truncatedPercent = MathFloor(rangeSizePercent * 1000) / 1000;
   
   // Check minimum range size
   if(minSize > 0 && rangeSizePercent < minSize)
   {
      Print("Range too small: ", StringFormat("%.3f", truncatedPercent), "% (min: ", minSize, "%)");
      return false;
   }
   
   // Check maximum range size
   if(maxSize > 0 && rangeSizePercent > maxSize)
   {
      Print("Range too large: ", StringFormat("%.3f", truncatedPercent), "% (max: ", maxSize, "%)");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if Trade Passes All Filters                                  |
//+------------------------------------------------------------------+
bool PassesFilters(bool isLong)
{
   // Spread Filter
   if(InpMaxSpread > 0)
   {
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double spread = (ask - bid) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      
      if(spread > InpMaxSpread)
      {
         Print("‚ùå Trade rejected: Spread too high (", DoubleToString(spread, 1), " points, max: ", InpMaxSpread, ")");
         return false;
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if Trading is Allowed on This Day                            |
//+------------------------------------------------------------------+
bool IsTradingDayAllowed(int dayOfWeek)
{
   // dayOfWeek: 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
   switch(dayOfWeek)
   {
      case 1: return InpTradeMonday;
      case 2: return InpTradeTuesday;
      case 3: return InpTradeWednesday;
      case 4: return InpTradeThursday;
      case 5: return InpTradeFriday;
      default: return false; // Don't trade on weekends
   }
}

//+------------------------------------------------------------------+
//| Get Breakout Setting for Day                                       |
//+------------------------------------------------------------------+
bool GetBreakoutSetting(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayBreakout;
      case 2: return InpTuesdayBreakout;
      case 3: return InpWednesdayBreakout;
      case 4: return InpThursdayBreakout;
      case 5: return InpFridayBreakout;
      default: return false;
   }
}

//+------------------------------------------------------------------+
//| Get Breakdown Setting for Day                                      |
//+------------------------------------------------------------------+
bool GetBreakdownSetting(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayBreakdown;
      case 2: return InpTuesdayBreakdown;
      case 3: return InpWednesdayBreakdown;
      case 4: return InpThursdayBreakdown;
      case 5: return InpFridayBreakdown;
      default: return false;
   }
}

//+------------------------------------------------------------------+
//| Get Profit Target for Day                                          |
//+------------------------------------------------------------------+
double GetProfitTarget(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayProfitTarget;
      case 2: return InpTuesdayProfitTarget;
      case 3: return InpWednesdayProfitTarget;
      case 4: return InpThursdayProfitTarget;
      case 5: return InpFridayProfitTarget;
      default: return 50.0;
   }
}

//+------------------------------------------------------------------+
//| Get Stop Loss for Day                                              |
//+------------------------------------------------------------------+
double GetStopLoss(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayStopLoss;
      case 2: return InpTuesdayStopLoss;
      case 3: return InpWednesdayStopLoss;
      case 4: return InpThursdayStopLoss;
      case 5: return InpFridayStopLoss;
      default: return 100.0;
   }
}

//+------------------------------------------------------------------+
//| Get Min ORB Size for Day                                           |
//+------------------------------------------------------------------+
double GetMinORBSize(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayMinORBSize;
      case 2: return InpTuesdayMinORBSize;
      case 3: return InpWednesdayMinORBSize;
      case 4: return InpThursdayMinORBSize;
      case 5: return InpFridayMinORBSize;
      default: return 0.0;
   }
}

//+------------------------------------------------------------------+
//| Get Max ORB Size for Day                                           |
//+------------------------------------------------------------------+
double GetMaxORBSize(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayMaxORBSize;
      case 2: return InpTuesdayMaxORBSize;
      case 3: return InpWednesdayMaxORBSize;
      case 4: return InpThursdayMaxORBSize;
      case 5: return InpFridayMaxORBSize;
      default: return 0.5;
   }
}

//+------------------------------------------------------------------+
//| Close All Positions                                                |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   int closedCount = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            double profit = PositionGetDouble(POSITION_PROFIT);
            if(trade.PositionClose(ticket))
            {
               Print("üïê END OF DAY CLOSE - Ticket #", ticket, " Profit: $", DoubleToString(profit, 2));
               closedCount++;
            }
         }
      }
   }
   
   if(closedCount > 0)
   {
      Print("üìä Total positions closed at end of day: ", closedCount);
   }
}

//+------------------------------------------------------------------+
//| Add Virtual Stop Loss                                              |
//+------------------------------------------------------------------+
void AddVirtualStopLoss(ulong ticket, double slPrice, bool isLong)
{
   ArrayResize(virtualStops, virtualStopsCount + 1);
   virtualStops[virtualStopsCount].ticket = ticket;
   virtualStops[virtualStopsCount].slPrice = slPrice;
   virtualStops[virtualStopsCount].isLong = isLong;
   virtualStopsCount++;
   
   Print("üõ°Ô∏è Virtual SL added for ticket #", ticket, " at ", slPrice, " (", (isLong ? "Long" : "Short"), ")");
}

//+------------------------------------------------------------------+
//| Check Virtual Stop Losses                                          |
//+------------------------------------------------------------------+
void CheckVirtualStopLosses()
{
   if(virtualStopsCount == 0)
      return;
   
   double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   for(int i = virtualStopsCount - 1; i >= 0; i--)
   {
      ulong ticket = virtualStops[i].ticket;
      double slPrice = virtualStops[i].slPrice;
      bool isLong = virtualStops[i].isLong;
      
      // Check if position still exists
      if(!PositionSelectByTicket(ticket))
      {
         // Position closed, remove from virtual stops
         RemoveVirtualStopLoss(i);
         continue;
      }
      
      // Check if virtual SL is hit
      bool slHit = false;
      if(isLong && currentBid <= slPrice)
      {
         slHit = true;
         Print("üö® Virtual SL HIT for Long #", ticket, " - Bid: ", currentBid, " <= SL: ", slPrice);
      }
      else if(!isLong && currentAsk >= slPrice)
      {
         slHit = true;
         Print("üö® Virtual SL HIT for Short #", ticket, " - Ask: ", currentAsk, " >= SL: ", slPrice);
      }
      
      if(slHit)
      {
         // Close position
         double profit = PositionGetDouble(POSITION_PROFIT);
         if(trade.PositionClose(ticket))
         {
            Print("üõ°Ô∏è VIRTUAL SL HIT - Position #", ticket, " closed. Profit: $", DoubleToString(profit, 2));
            RemoveVirtualStopLoss(i);
         }
         else
         {
            Print("‚ùå Failed to close position #", ticket, " - Error: ", GetLastError());
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Remove Virtual Stop Loss                                           |
//+------------------------------------------------------------------+
void RemoveVirtualStopLoss(int index)
{
   if(index < 0 || index >= virtualStopsCount)
      return;
   
   // Shift array elements
   for(int i = index; i < virtualStopsCount - 1; i++)
   {
      virtualStops[i] = virtualStops[i + 1];
   }
   
   virtualStopsCount--;
   ArrayResize(virtualStops, virtualStopsCount);
}

//+------------------------------------------------------------------+
//| Monitor Partial Take Profit                                        |
//+------------------------------------------------------------------+
void MonitorPartialTP(ulong ticket, double tp1Price, double closePercent, bool isLong)
{
   ArrayResize(partialTPs, partialTPsCount + 1);
   partialTPs[partialTPsCount].ticket = ticket;
   partialTPs[partialTPsCount].tp1Price = tp1Price;
   partialTPs[partialTPsCount].closePercent = closePercent;
   partialTPs[partialTPsCount].isLong = isLong;
   partialTPs[partialTPsCount].tp1Hit = false;
   partialTPsCount++;
   
   Print("üìä Monitoring partial TP for ticket #", ticket, " - TP1: ", tp1Price, " Close: ", closePercent, "%");
}

//+------------------------------------------------------------------+
//| Check Partial Take Profits                                         |
//+------------------------------------------------------------------+
void CheckPartialTakeProfits()
{
   if(partialTPsCount == 0)
      return;
   
   double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   for(int i = partialTPsCount - 1; i >= 0; i--)
   {
      ulong ticket = partialTPs[i].ticket;
      double tp1Price = partialTPs[i].tp1Price;
      double closePercent = partialTPs[i].closePercent;
      bool isLong = partialTPs[i].isLong;
      bool tp1Hit = partialTPs[i].tp1Hit;
      
      // Check if position still exists
      if(!PositionSelectByTicket(ticket))
      {
         // Position closed, remove from monitoring
         RemovePartialTP(i);
         continue;
      }
      
      // Double-check position still exists before attempting partial close
      if(!PositionSelectByTicket(ticket))
      {
         RemovePartialTP(i);
         continue;
      }
      
      // Check if TP1 is hit (only once)
      if(!tp1Hit)
      {
         bool tp1Reached = false;
         if(isLong && currentBid >= tp1Price)
         {
            tp1Reached = true;
            Print("üéØ TP1 HIT for Long #", ticket, " - Bid: ", currentBid, " >= TP1: ", tp1Price);
         }
         else if(!isLong && currentAsk <= tp1Price)
         {
            tp1Reached = true;
            Print("üéØ TP1 HIT for Short #", ticket, " - Ask: ", currentAsk, " <= TP1: ", tp1Price);
         }
         
         if(tp1Reached)
         {
            // Close partial position
            double currentVolume = PositionGetDouble(POSITION_VOLUME);
            double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
            double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
            
            // Calculate close volume and normalize to lot step
            double closeVolume = MathFloor((currentVolume * closePercent / 100.0) / lotStep) * lotStep;
            
            // Ensure we don't close more than available
            if(closeVolume > currentVolume)
               closeVolume = currentVolume;
            
            // Ensure minimum lot
            if(closeVolume < minLot)
               closeVolume = minLot;
            
            // Ensure remaining volume is also valid
            double remainingVolume = currentVolume - closeVolume;
            if(remainingVolume > 0 && remainingVolume < minLot)
            {
               // Adjust close volume to leave at least minLot
               closeVolume = currentVolume - minLot;
               if(closeVolume < minLot)
               {
                  Print("‚ö† Cannot partial close - remaining volume would be too small");
                  partialTPs[i].tp1Hit = true;  // Mark as hit to avoid retry
                  continue;
               }
            }
            
            // Close partial
            if(trade.PositionClosePartial(ticket, closeVolume))
            {
               Print("‚úì Partial TP1 closed - Ticket #", ticket, 
                     " Closed: ", DoubleToString(closeVolume, 2), " lots (", closePercent, "%)", 
                     " Remaining: ", DoubleToString(remainingVolume, 2), " lots");
               partialTPs[i].tp1Hit = true;
            }
            else
            {
               Print("‚ùå Failed to close partial TP1 - Ticket #", ticket, " Error: ", GetLastError());
               // Mark as hit anyway to avoid infinite retries
               partialTPs[i].tp1Hit = true;
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Remove Partial TP                                                  |
//+------------------------------------------------------------------+
void RemovePartialTP(int index)
{
   if(index < 0 || index >= partialTPsCount)
      return;
   
   // Shift array elements
   for(int i = index; i < partialTPsCount - 1; i++)
   {
      partialTPs[i] = partialTPs[i + 1];
   }
   
   partialTPsCount--;
   ArrayResize(partialTPs, partialTPsCount);
}
//+------------------------------------------------------------------+
