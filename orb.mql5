//+------------------------------------------------------------------+
//|                                                          orb.mql5 |
//|                                    Opening Range Breakout Strategy |
//+------------------------------------------------------------------+
#property copyright "ORB Strategy"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

//--- Input Parameters
input group "=== Range Settings ==="
input int InpRangeMinutes = 15;              // Opening Range Duration (minutes)
input ENUM_TIMEFRAMES InpCandleTimeframe = PERIOD_M15;  // Candle Timeframe for Entry
input int InpMaxTradesPerDay = 1;            // Max Trades Per Day

input group "=== MONDAY ==="
input bool InpTradeMonday = true;            // Trade on Monday
input bool InpMondayBreakout = true;         // Trade ORB breakout
input bool InpMondayBreakdown = true;        // Trade ORB breakdown
input double InpMondayProfitTarget = 50.0;   // Profit target (% of ORB size)
input double InpMondayStopLoss = 100.0;      // Stop loss (% of ORB size)
input double InpMondayMinORBSize = 0.0;      // Min ORB size %
input double InpMondayMaxORBSize = 0.5;      // Max ORB size %

input group "=== TUESDAY ==="
input bool InpTradeTuesday = true;           // Trade on Tuesday
input bool InpTuesdayBreakout = true;        // Trade ORB breakout
input bool InpTuesdayBreakdown = true;       // Trade ORB breakdown
input double InpTuesdayProfitTarget = 50.0;  // Profit target (% of ORB size)
input double InpTuesdayStopLoss = 100.0;     // Stop loss (% of ORB size)
input double InpTuesdayMinORBSize = 0.0;     // Min ORB size %
input double InpTuesdayMaxORBSize = 0.5;     // Max ORB size %

input group "=== WEDNESDAY ==="
input bool InpTradeWednesday = true;         // Trade on Wednesday
input bool InpWednesdayBreakout = true;      // Trade ORB breakout
input bool InpWednesdayBreakdown = true;     // Trade ORB breakdown
input double InpWednesdayProfitTarget = 50.0; // Profit target (% of ORB size)
input double InpWednesdayStopLoss = 100.0;   // Stop loss (% of ORB size)
input double InpWednesdayMinORBSize = 0.0;   // Min ORB size %
input double InpWednesdayMaxORBSize = 0.5;   // Max ORB size %

input group "=== THURSDAY ==="
input bool InpTradeThursday = true;          // Trade on Thursday
input bool InpThursdayBreakout = true;       // Trade ORB breakout
input bool InpThursdayBreakdown = true;      // Trade ORB breakdown
input double InpThursdayProfitTarget = 50.0; // Profit target (% of ORB size)
input double InpThursdayStopLoss = 100.0;    // Stop loss (% of ORB size)
input double InpThursdayMinORBSize = 0.0;    // Min ORB size %
input double InpThursdayMaxORBSize = 0.5;    // Max ORB size %

input group "=== FRIDAY ==="
input bool InpTradeFriday = true;            // Trade on Friday
input bool InpFridayBreakout = true;         // Trade ORB breakout
input bool InpFridayBreakdown = true;        // Trade ORB breakdown
input double InpFridayProfitTarget = 50.0;   // Profit target (% of ORB size)
input double InpFridayStopLoss = 100.0;      // Stop loss (% of ORB size)
input double InpFridayMinORBSize = 0.0;      // Min ORB size %
input double InpFridayMaxORBSize = 0.5;      // Max ORB size %

input group "=== Filters ==="
input bool InpUseEMA200Filter = true;        // Use EMA200 Filter
input bool InpUseGapFilter = false;          // Use Gap Direction Filter
input bool InpUseVolumeFilter = false;       // Use Volume Filter
input int InpVolumePeriod = 20;              // Volume Average Period

input group "=== Risk Management ==="
input double InpRiskPercent = 1.0;           // Risk Per Trade (% of account)
input double InpMaxLossPerTrade = 0.0;       // Max Loss Per Trade (0=disabled, in account currency)
input double InpTP1Percent = 40.0;           // TP1 (% of ORB size)
input double InpTP1PositionPercent = 50.0;   // TP1 Position Size (% to close)
input int InpMaxSlippagePoints = 10;         // Max Slippage (points)

input group "=== Time Settings ==="
input int InpStartHour = 9;                  // Market Open Hour
input int InpStartMinute = 30;               // Market Open Minute
input bool InpUseTimeBasedClose = true;      // Use Time-Based Position Close
input int InpCloseHour = 15;                 // Close All Positions Hour
input int InpCloseMinute = 45;               // Close All Positions Minute

input group "=== EMA Settings ==="
input int InpEMA200Period = 200;             // EMA200 Period

//--- Global Variables
CTrade trade;
double rangeHigh = 0;
double rangeLow = 0;
bool rangeSet = false;
bool tradeTakenToday = false;
int tradesCountToday = 0;
datetime currentDay = 0;
datetime lastBarTime = 0;
int ema200Handle = INVALID_HANDLE;
double ema200Buffer[];
int currentDayOfWeek = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(InpMaxSlippagePoints);
   trade.SetTypeFilling(ORDER_FILLING_FOK);
   
   if(InpUseEMA200Filter)
   {
      ema200Handle = iMA(_Symbol, PERIOD_CURRENT, InpEMA200Period, 0, MODE_EMA, PRICE_CLOSE);
      if(ema200Handle == INVALID_HANDLE)
      {
         Print("Failed to create EMA200 indicator");
         return(INIT_FAILED);
      }
      ArraySetAsSeries(ema200Buffer, true);
   }
   
   Print("ORB Strategy initialized successfully");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if(ema200Handle != INVALID_HANDLE)
      IndicatorRelease(ema200Handle);
}

//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   // Reset daily variables at start of new day
   if(timeStruct.day != currentDay)
   {
      rangeHigh = 0;
      rangeLow = 0;
      rangeSet = false;
      tradeTakenToday = false;
      tradesCountToday = 0;
      lastBarTime = 0;
      currentDay = timeStruct.day;
      currentDayOfWeek = timeStruct.day_of_week;
   }
   
   // Check if trading is allowed on this day
   if(!IsTradingDayAllowed(currentDayOfWeek))
      return;
   
   // Close all positions at end of day (if enabled)
   if(InpUseTimeBasedClose && timeStruct.hour == InpCloseHour && timeStruct.min >= InpCloseMinute)
   {
      CloseAllPositions();
      return;
   }
   
   // Set opening range
   if(!rangeSet)
   {
      SetOpeningRange(timeStruct);
      return;
   }
   
   // Check if we can still take entries
   if(tradesCountToday >= InpMaxTradesPerDay)
      return;
   
   // Check for breakout
   CheckForBreakout();
}

//+------------------------------------------------------------------+
//| Set Opening Range                                                  |
//+------------------------------------------------------------------+
void SetOpeningRange(MqlDateTime &timeStruct)
{
   // Check if market has opened
   int minutesSinceOpen = GetMinutesSinceOpen(timeStruct);
   
   if(minutesSinceOpen < 0)
      return; // Market hasn't opened yet
   
   if(minutesSinceOpen >= InpRangeMinutes)
   {
      // Range period is over, calculate range
      if(rangeHigh == 0 && rangeLow == 0)
      {
         CalculateRange();
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Opening Range High and Low                               |
//+------------------------------------------------------------------+
void CalculateRange()
{
   datetime marketOpen = GetMarketOpenTime();
   datetime rangeEnd = marketOpen + InpRangeMinutes * 60;
   
   int bars = Bars(_Symbol, PERIOD_M1, marketOpen, rangeEnd);
   if(bars < InpRangeMinutes)
   {
      Print("Not enough bars to calculate range");
      return;
   }
   
   rangeHigh = 0;
   rangeLow = DBL_MAX;
   
   for(int i = 0; i < bars; i++)
   {
      datetime barTime = iTime(_Symbol, PERIOD_M1, i);
      if(barTime >= marketOpen && barTime < rangeEnd)
      {
         double high = iHigh(_Symbol, PERIOD_M1, i);
         double low = iLow(_Symbol, PERIOD_M1, i);
         
         if(high > rangeHigh) rangeHigh = high;
         if(low < rangeLow) rangeLow = low;
      }
   }
   
   if(rangeHigh > 0 && rangeLow < DBL_MAX)
   {
      // Check if range size is within acceptable limits
      if(!IsValidRangeSize(currentDayOfWeek))
      {
         Print("Range rejected - Size outside limits");
         rangeHigh = 0;
         rangeLow = 0;
         return;
      }
      
      rangeSet = true;
      double rangeSize = rangeHigh - rangeLow;
      double rangeSizePercent = (rangeSize / rangeHigh) * 100.0;
      Print("Opening Range Set - High: ", rangeHigh, " Low: ", rangeLow, " Size: ", rangeSize, " (", rangeSizePercent, "%)");
   }
}

//+------------------------------------------------------------------+
//| Get Minutes Since Market Open                                      |
//+------------------------------------------------------------------+
int GetMinutesSinceOpen(MqlDateTime &timeStruct)
{
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int openMinutes = InpStartHour * 60 + InpStartMinute;
   
   return currentMinutes - openMinutes;
}

//+------------------------------------------------------------------+
//| Get Market Open Time for Today                                     |
//+------------------------------------------------------------------+
datetime GetMarketOpenTime()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   timeStruct.hour = InpStartHour;
   timeStruct.min = InpStartMinute;
   timeStruct.sec = 0;
   
   return StructToTime(timeStruct);
}

//+------------------------------------------------------------------+
//| Calculate Max SL Distance Based on Max Loss                        |
//+------------------------------------------------------------------+
double CalculateMaxSLDistance(double maxLoss)
{
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   
   // Calculate max distance in price based on max loss amount
   // maxLoss = (slDistance / tickSize) * tickValue
   // slDistance = (maxLoss * tickSize) / tickValue
   double maxSlDistance = (maxLoss * tickSize) / tickValue;
   
   return maxSlDistance;
}

//+------------------------------------------------------------------+
//| Check for Breakout and Enter Trade                                 |
//+------------------------------------------------------------------+
void CheckForBreakout()
{
   // Check if new bar has formed on selected timeframe
   datetime currentBarTime = iTime(_Symbol, InpCandleTimeframe, 0);
   if(currentBarTime == lastBarTime)
      return; // Wait for bar to close
   
   lastBarTime = currentBarTime;
   
   // Get the closed bar data (bar index 1)
   double closedBarClose = iClose(_Symbol, InpCandleTimeframe, 1);
   double closedBarHigh = iHigh(_Symbol, InpCandleTimeframe, 1);
   double closedBarLow = iLow(_Symbol, InpCandleTimeframe, 1);
   
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   double rangeSize = rangeHigh - rangeLow;
   
   // Get day-specific settings
   bool tradeBreakout = GetBreakoutSetting(currentDayOfWeek);
   bool tradeBreakdown = GetBreakdownSetting(currentDayOfWeek);
   double profitTarget = GetProfitTarget(currentDayOfWeek);
   double stopLoss = GetStopLoss(currentDayOfWeek);
   
   // Check for bullish breakout - closed bar must close above range high
   if(closedBarClose > rangeHigh && tradeBreakout)
   {
      if(PassesFilters(true))
      {
         // Calculate SL and TP based on ORB levels
         // SL: percentage below ORB Low
         double slOffset = rangeSize * (stopLoss / 100.0);
         double sl = NormalizeDouble(rangeLow - slOffset, digits);
         
         // Check if max loss override is needed
         if(InpMaxLossPerTrade > 0)
         {
            double maxSlDistance = CalculateMaxSLDistance(InpMaxLossPerTrade);
            double currentSlDistance = closedBarClose - sl;
            if(currentSlDistance > maxSlDistance)
            {
               sl = NormalizeDouble(closedBarClose - maxSlDistance, digits);
               Print("SL adjusted by max loss limit - New SL: ", sl);
            }
         }
         
         // TP1: partial take profit
         double tp1Offset = rangeSize * (InpTP1Percent / 100.0);
         double tp1 = NormalizeDouble(rangeHigh + tp1Offset, digits);
         
         // TP2: final take profit
         double tp2Offset = rangeSize * (profitTarget / 100.0);
         double tp2 = NormalizeDouble(rangeHigh + tp2Offset, digits);
         
         // Calculate lot size based on risk percentage
         double slDistance = closedBarClose - sl;
         double lotSize = CalculateLotSize(slDistance);
         
         // Split position: TP1 gets specified %, TP2 gets the rest
         double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
         double lotSize1 = NormalizeDouble((lotSize * InpTP1PositionPercent / 100.0) / lotStep, 0) * lotStep;
         double lotSize2 = NormalizeDouble(lotSize - lotSize1, 2);
         
         // Ensure minimum lot sizes
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         if(lotSize1 < minLot) lotSize1 = minLot;
         if(lotSize2 < minLot) lotSize2 = minLot;
         
         // Open first position with TP1
         if(trade.Buy(lotSize1, _Symbol, 0, sl, tp1, "ORB Long TP1"))
         {
            Print("Long TP1 opened - Entry: ", closedBarClose, " SL: ", sl, " TP1: ", tp1, " (", InpTP1Percent, "%) Lots: ", lotSize1);
         }
         
         // Open second position with TP2
         if(trade.Buy(lotSize2, _Symbol, 0, sl, tp2, "ORB Long TP2"))
         {
            Print("Long TP2 opened - Entry: ", closedBarClose, " SL: ", sl, " TP2: ", tp2, " (", profitTarget, "%) Lots: ", lotSize2);
         }
         
         tradesCountToday++;
         tradeTakenToday = true;
      }
   }
   // Check for bearish breakout - closed bar must close below range low
   else if(closedBarClose < rangeLow && tradeBreakdown)
   {
      if(PassesFilters(false))
      {
         // Calculate SL and TP based on ORB levels
         // SL: percentage above ORB High
         double slOffset = rangeSize * (stopLoss / 100.0);
         double sl = NormalizeDouble(rangeHigh + slOffset, digits);
         
         // Check if max loss override is needed
         if(InpMaxLossPerTrade > 0)
         {
            double maxSlDistance = CalculateMaxSLDistance(InpMaxLossPerTrade);
            double currentSlDistance = sl - closedBarClose;
            if(currentSlDistance > maxSlDistance)
            {
               sl = NormalizeDouble(closedBarClose + maxSlDistance, digits);
               Print("SL adjusted by max loss limit - New SL: ", sl);
            }
         }
         
         // TP1: partial take profit
         double tp1Offset = rangeSize * (InpTP1Percent / 100.0);
         double tp1 = NormalizeDouble(rangeLow - tp1Offset, digits);
         
         // TP2: final take profit
         double tp2Offset = rangeSize * (profitTarget / 100.0);
         double tp2 = NormalizeDouble(rangeLow - tp2Offset, digits);
         
         // Calculate lot size based on risk percentage
         double slDistance = sl - closedBarClose;
         double lotSize = CalculateLotSize(slDistance);
         
         // Split position: TP1 gets specified %, TP2 gets the rest
         double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
         double lotSize1 = NormalizeDouble((lotSize * InpTP1PositionPercent / 100.0) / lotStep, 0) * lotStep;
         double lotSize2 = NormalizeDouble(lotSize - lotSize1, 2);
         
         // Ensure minimum lot sizes
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         if(lotSize1 < minLot) lotSize1 = minLot;
         if(lotSize2 < minLot) lotSize2 = minLot;
         
         // Open first position with TP1
         if(trade.Sell(lotSize1, _Symbol, 0, sl, tp1, "ORB Short TP1"))
         {
            Print("Short TP1 opened - Entry: ", closedBarClose, " SL: ", sl, " TP1: ", tp1, " (", InpTP1Percent, "%) Lots: ", lotSize1);
         }
         
         // Open second position with TP2
         if(trade.Sell(lotSize2, _Symbol, 0, sl, tp2, "ORB Short TP2"))
         {
            Print("Short TP2 opened - Entry: ", closedBarClose, " SL: ", sl, " TP2: ", tp2, " (", profitTarget, "%) Lots: ", lotSize2);
         }
         
         tradesCountToday++;
         tradeTakenToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size Based on Risk Percentage                        |
//+------------------------------------------------------------------+
double CalculateLotSize(double slDistance)
{
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * (InpRiskPercent / 100.0);
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // Calculate lot size based on risk
   double lotSize = (riskAmount / slDistance) / (tickValue / tickSize);
   
   // Normalize to lot step
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   
   // Ensure within broker limits
   if(lotSize < minLot) lotSize = minLot;
   if(lotSize > maxLot) lotSize = maxLot;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Check if Range Size is Valid                                       |
//+------------------------------------------------------------------+
bool IsValidRangeSize(int dayOfWeek)
{
   double rangeSize = rangeHigh - rangeLow;
   double rangeSizePercent = (rangeSize / rangeHigh) * 100.0;
   
   double minSize = GetMinORBSize(dayOfWeek);
   double maxSize = GetMaxORBSize(dayOfWeek);
   
   // Check minimum range size
   if(minSize > 0 && rangeSizePercent < minSize)
   {
      Print("Range too small: ", rangeSizePercent, "% (min: ", minSize, "%)");
      return false;
   }
   
   // Check maximum range size
   if(maxSize > 0 && rangeSizePercent > maxSize)
   {
      Print("Range too large: ", rangeSizePercent, "% (max: ", maxSize, "%)");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if Trade Passes All Filters                                  |
//+------------------------------------------------------------------+
bool PassesFilters(bool isLong)
{
   // EMA200 Filter
   if(InpUseEMA200Filter)
   {
      if(CopyBuffer(ema200Handle, 0, 0, 2, ema200Buffer) < 2)
      {
         Print("Failed to copy EMA200 buffer");
         return false;
      }
      
      double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      
      if(isLong && currentPrice < ema200Buffer[0])
      {
         Print("Long rejected: Price below EMA200");
         return false;
      }
      if(!isLong && currentPrice > ema200Buffer[0])
      {
         Print("Short rejected: Price above EMA200");
         return false;
      }
   }
   
   // Gap Filter
   if(InpUseGapFilter)
   {
      double yesterdayClose = iClose(_Symbol, PERIOD_D1, 1);
      double todayOpen = iOpen(_Symbol, PERIOD_D1, 0);
      
      bool gapUp = todayOpen > yesterdayClose;
      bool gapDown = todayOpen < yesterdayClose;
      
      if(isLong && gapDown)
      {
         Print("Long rejected: Gap down detected");
         return false;
      }
      if(!isLong && gapUp)
      {
         Print("Short rejected: Gap up detected");
         return false;
      }
   }
   
   // Volume Filter
   if(InpUseVolumeFilter)
   {
      long currentVolume = iVolume(_Symbol, PERIOD_M1, 0);
      long totalVolume = 0;
      
      for(int i = 1; i <= InpVolumePeriod; i++)
      {
         totalVolume += iVolume(_Symbol, PERIOD_M1, i);
      }
      long avgVolume = totalVolume / InpVolumePeriod;
      
      if(currentVolume < avgVolume)
      {
         Print("Trade rejected: Volume below average");
         return false;
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if Trading is Allowed on This Day                            |
//+------------------------------------------------------------------+
bool IsTradingDayAllowed(int dayOfWeek)
{
   // dayOfWeek: 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
   switch(dayOfWeek)
   {
      case 1: return InpTradeMonday;
      case 2: return InpTradeTuesday;
      case 3: return InpTradeWednesday;
      case 4: return InpTradeThursday;
      case 5: return InpTradeFriday;
      default: return false; // Don't trade on weekends
   }
}

//+------------------------------------------------------------------+
//| Get Breakout Setting for Day                                       |
//+------------------------------------------------------------------+
bool GetBreakoutSetting(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayBreakout;
      case 2: return InpTuesdayBreakout;
      case 3: return InpWednesdayBreakout;
      case 4: return InpThursdayBreakout;
      case 5: return InpFridayBreakout;
      default: return false;
   }
}

//+------------------------------------------------------------------+
//| Get Breakdown Setting for Day                                      |
//+------------------------------------------------------------------+
bool GetBreakdownSetting(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayBreakdown;
      case 2: return InpTuesdayBreakdown;
      case 3: return InpWednesdayBreakdown;
      case 4: return InpThursdayBreakdown;
      case 5: return InpFridayBreakdown;
      default: return false;
   }
}

//+------------------------------------------------------------------+
//| Get Profit Target for Day                                          |
//+------------------------------------------------------------------+
double GetProfitTarget(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayProfitTarget;
      case 2: return InpTuesdayProfitTarget;
      case 3: return InpWednesdayProfitTarget;
      case 4: return InpThursdayProfitTarget;
      case 5: return InpFridayProfitTarget;
      default: return 50.0;
   }
}

//+------------------------------------------------------------------+
//| Get Stop Loss for Day                                              |
//+------------------------------------------------------------------+
double GetStopLoss(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayStopLoss;
      case 2: return InpTuesdayStopLoss;
      case 3: return InpWednesdayStopLoss;
      case 4: return InpThursdayStopLoss;
      case 5: return InpFridayStopLoss;
      default: return 100.0;
   }
}

//+------------------------------------------------------------------+
//| Get Min ORB Size for Day                                           |
//+------------------------------------------------------------------+
double GetMinORBSize(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayMinORBSize;
      case 2: return InpTuesdayMinORBSize;
      case 3: return InpWednesdayMinORBSize;
      case 4: return InpThursdayMinORBSize;
      case 5: return InpFridayMinORBSize;
      default: return 0.0;
   }
}

//+------------------------------------------------------------------+
//| Get Max ORB Size for Day                                           |
//+------------------------------------------------------------------+
double GetMaxORBSize(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayMaxORBSize;
      case 2: return InpTuesdayMaxORBSize;
      case 3: return InpWednesdayMaxORBSize;
      case 4: return InpThursdayMaxORBSize;
      case 5: return InpFridayMaxORBSize;
      default: return 0.5;
   }
}

//+------------------------------------------------------------------+
//| Close All Positions                                                |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}
//+------------------------------------------------------------------+
