//+------------------------------------------------------------------+
//|                                                      orbtp3.mql5 |
//|                        ORB Strategy with Virtual Move Stop       |
//+------------------------------------------------------------------+
#property copyright "ORB Strategy"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

//--- Input Parameters
input group "=== Time Settings (Broker Server Time) ==="
input int InpORBStartHour = 9;                   // ORB Start Hour
input int InpORBStartMinute = 30;                // ORB Start Minute
input int InpORBEndHour = 9;                     // ORB End Hour
input int InpORBEndMinute = 45;                  // ORB End Minute
input int InpSessionStartHour = 9;               // Session Start Hour
input int InpSessionStartMinute = 30;            // Session Start Minute
input int InpSessionEndHour = 16;                // Session End Hour
input int InpSessionEndMinute = 0;               // Session End Minute

input group "=== General Settings ==="
input double InpLotSize = 0.1;                   // Lot Size
input double InpMaxLossPerTrade = 0.0;           // Max Loss Per Trade $ (0=disabled)
input ENUM_TIMEFRAMES InpSignalTimeframe = PERIOD_M1;  // Signal Detection Timeframe

input group "=== MONDAY ==="
input bool InpTradeMonday = true;                // Trade on Monday
input bool InpMondayBreakout = true;             // Trade ORB breakout
input bool InpMondayBreakdown = true;            // Trade ORB breakdown
input double InpMondayProfitTarget = 50.0;       // Profit target (% of ORB size)
input double InpMondayStopLoss = 100.0;          // Stop loss (% of ORB size)
input double InpMondayMinORBSize = 0.0;          // Min ORB size %
input double InpMondayMaxORBSize = 0.5;          // Max ORB size %
input bool InpMondayActivateMoveStop = true;     // Activate Move Stop?
input double InpMondayTriggerPercent = 85.0;     // Trigger %
input double InpMondayTargetPercent = 20.0;      // Target %

input group "=== TUESDAY ==="
input bool InpTradeTuesday = true;               // Trade on Tuesday
input bool InpTuesdayBreakout = true;            // Trade ORB breakout
input bool InpTuesdayBreakdown = true;           // Trade ORB breakdown
input double InpTuesdayProfitTarget = 50.0;      // Profit target (% of ORB size)
input double InpTuesdayStopLoss = 100.0;         // Stop loss (% of ORB size)
input double InpTuesdayMinORBSize = 0.0;         // Min ORB size %
input double InpTuesdayMaxORBSize = 0.5;         // Max ORB size %
input bool InpTuesdayActivateMoveStop = true;    // Activate Move Stop?
input double InpTuesdayTriggerPercent = 85.0;    // Trigger %
input double InpTuesdayTargetPercent = 20.0;     // Target %

input group "=== WEDNESDAY ==="
input bool InpTradeWednesday = true;             // Trade on Wednesday
input bool InpWednesdayBreakout = true;          // Trade ORB breakout
input bool InpWednesdayBreakdown = true;         // Trade ORB breakdown
input double InpWednesdayProfitTarget = 50.0;    // Profit target (% of ORB size)
input double InpWednesdayStopLoss = 100.0;       // Stop loss (% of ORB size)
input double InpWednesdayMinORBSize = 0.0;       // Min ORB size %
input double InpWednesdayMaxORBSize = 0.5;       // Max ORB size %
input bool InpWednesdayActivateMoveStop = true;  // Activate Move Stop?
input double InpWednesdayTriggerPercent = 85.0;  // Trigger %
input double InpWednesdayTargetPercent = 20.0;   // Target %

input group "=== THURSDAY ==="
input bool InpTradeThursday = true;              // Trade on Thursday
input bool InpThursdayBreakout = true;           // Trade ORB breakout
input bool InpThursdayBreakdown = true;          // Trade ORB breakdown
input double InpThursdayProfitTarget = 50.0;     // Profit target (% of ORB size)
input double InpThursdayStopLoss = 100.0;        // Stop loss (% of ORB size)
input double InpThursdayMinORBSize = 0.0;        // Min ORB size %
input double InpThursdayMaxORBSize = 0.5;        // Max ORB size %
input bool InpThursdayActivateMoveStop = true;   // Activate Move Stop?
input double InpThursdayTriggerPercent = 85.0;   // Trigger %
input double InpThursdayTargetPercent = 20.0;    // Target %

input group "=== FRIDAY ==="
input bool InpTradeFriday = true;                // Trade on Friday
input bool InpFridayBreakout = true;             // Trade ORB breakout
input bool InpFridayBreakdown = true;            // Trade ORB breakdown
input double InpFridayProfitTarget = 50.0;       // Profit target (% of ORB size)
input double InpFridayStopLoss = 100.0;          // Stop loss (% of ORB size)
input double InpFridayMinORBSize = 0.0;          // Min ORB size %
input double InpFridayMaxORBSize = 0.5;          // Max ORB size %
input bool InpFridayActivateMoveStop = true;     // Activate Move Stop?
input double InpFridayTriggerPercent = 85.0;     // Trigger %
input double InpFridayTargetPercent = 20.0;      // Target %

//--- Global Variables
CTrade trade;
double orbHigh = 0;
double orbLow = 0;
bool orbCalculated = false;
datetime orbStartTime = 0;
datetime orbEndTime = 0;
datetime lastResetDate = 0;
datetime lastBarTime = 0;
bool tradeTakenToday = false;
bool sessionClosed = false;

// Message tracking flags
bool orbMessagePrinted = false;
static bool initMessagePrinted = false;

// Virtual TP/SL tracking
struct VirtualTPSL
{
   ulong ticket;
   double virtualTP;
   double virtualSL;
   double triggerPrice;
   double targetSL;
   bool moveStopTriggered;
   bool isLong;
};
VirtualTPSL virtualPositions[];

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(10);
   trade.SetTypeFilling(ORDER_FILLING_FOK);
   
   if(!initMessagePrinted)
   {
      Print("=== ORB Strategy with Virtual Move Stop Initialized ===");
      Print("Broker Server Time Used | Lot Size: ", InpLotSize);
      Print("ORB Time: ", InpORBStartHour, ":", InpORBStartMinute, " - ", InpORBEndHour, ":", InpORBEndMinute);
      Print("Session: ", InpSessionStartHour, ":", InpSessionStartMinute, " - ", InpSessionEndHour, ":", InpSessionEndMinute);
      initMessagePrinted = true;
   }
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("ORB Strategy stopped");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check virtual TP/SL on every tick FIRST
   CheckVirtualTPSL();
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   datetime currentDate = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                       IntegerToString(timeStruct.mon) + "." + 
                                       IntegerToString(timeStruct.day));
   
   // Reset daily variables
   if(currentDate != lastResetDate)
   {
      lastResetDate = currentDate;
      lastBarTime = 0;
      orbCalculated = false;
      orbMessagePrinted = false;
      tradeTakenToday = false;
      sessionClosed = false;
      ArrayResize(virtualPositions, 0);
   }
   
   // Check session close FIRST (before session time check)
   CheckSessionClose();
   
   // Check session time
   if(!IsWithinSession()) return;
   
   // Check if today is a trading day
   int dayOfWeek = timeStruct.day_of_week;
   if(!IsTradingDay(dayOfWeek)) return;
   
   // Calculate ORB
   CalculateORB(dayOfWeek);
   
   // Check for trade signals
   if(orbCalculated && TimeCurrent() > orbEndTime)
   {
      CheckTradeSignals(dayOfWeek);
   }
}

//+------------------------------------------------------------------+
//| Check if within session time                                     |
//+------------------------------------------------------------------+
bool IsWithinSession()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int sessionStart = InpSessionStartHour * 60 + InpSessionStartMinute;
   int sessionEnd = InpSessionEndHour * 60 + InpSessionEndMinute;
   
   if(sessionEnd < sessionStart)
      return (currentMinutes >= sessionStart || currentMinutes < sessionEnd);
   else
      return (currentMinutes >= sessionStart && currentMinutes < sessionEnd);
}

//+------------------------------------------------------------------+
//| Calculate Opening Range                                          |
//+------------------------------------------------------------------+
void CalculateORB(int dayOfWeek)
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   datetime orbStart = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                    IntegerToString(timeStruct.mon) + "." + 
                                    IntegerToString(timeStruct.day) + " " +
                                    IntegerToString(InpORBStartHour) + ":" + 
                                    IntegerToString(InpORBStartMinute));
   
   datetime orbEnd = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                  IntegerToString(timeStruct.mon) + "." + 
                                  IntegerToString(timeStruct.day) + " " +
                                  IntegerToString(InpORBEndHour) + ":" + 
                                  IntegerToString(InpORBEndMinute));
   
   if(orbStartTime != orbStart)
   {
      orbStartTime = orbStart;
      orbEndTime = orbEnd;
      orbCalculated = false;
      orbMessagePrinted = false;
      orbHigh = 0;
      orbLow = 0;
   }
   
   // During ORB period
   if(TimeCurrent() >= orbStartTime && TimeCurrent() <= orbEndTime)
   {
      double high = iHigh(_Symbol, PERIOD_CURRENT, 0);
      double low = iLow(_Symbol, PERIOD_CURRENT, 0);
      
      if(orbHigh == 0 || high > orbHigh) orbHigh = high;
      if(orbLow == 0 || low < orbLow) orbLow = low;
   }
   
   // After ORB period - calculate once
   if(TimeCurrent() > orbEndTime && !orbCalculated && !orbMessagePrinted && orbHigh > 0 && orbLow > 0)
   {
      double orbSize = (orbHigh - orbLow) / orbLow * 100.0;
      double minSize = GetMinORBSize(dayOfWeek);
      double maxSize = GetMaxORBSize(dayOfWeek);
      
      if(orbSize >= minSize && orbSize <= maxSize)
      {
         orbCalculated = true;
         Print("‚úì ORB calculated - High: ", orbHigh, " | Low: ", orbLow, " | Size: ", DoubleToString(orbSize, 2), "%");
      }
      else
      {
         Print("‚ùå ORB rejected - Size: ", DoubleToString(orbSize, 2), "% (Range: ", minSize, "% - ", maxSize, "%)");
      }
      
      orbMessagePrinted = true;  // Set flag after printing (success or rejection)
   }
}

//+------------------------------------------------------------------+
//| Check for trade signals                                          |
//+------------------------------------------------------------------+
void CheckTradeSignals(int dayOfWeek)
{
   // Skip if already have position
   if(PositionsTotal() > 0) return;
   
   // Skip if already traded today (only 1 trade per day)
   if(tradeTakenToday) return;
   
   // Double-check session time (safety)
   if(!IsWithinSession())
   {
      Print("‚ö†Ô∏è Trade signal blocked - Outside session time");
      return;
   }
   
   // Wait for new bar to close before checking signal
   datetime currentBarTime = iTime(_Symbol, InpSignalTimeframe, 0);
   if(currentBarTime == lastBarTime)
      return; // Wait for bar to close
   
   lastBarTime = currentBarTime;
   
   // Get the CLOSED bar data (bar index 1)
   double closedBarClose = iClose(_Symbol, InpSignalTimeframe, 1);
   double orbRange = orbHigh - orbLow;
   
   bool tradeBreakout = GetBreakoutSetting(dayOfWeek);
   bool tradeBreakdown = GetBreakdownSetting(dayOfWeek);
   double profitTarget = GetProfitTarget(dayOfWeek);
   double stopLoss = GetStopLoss(dayOfWeek);
   
   // Check for breakout (buy signal) - closed bar must close above ORB High
   if(tradeBreakout && !tradeTakenToday && closedBarClose > orbHigh)
   {
      double tp = NormalizeDouble(orbHigh + (orbRange * profitTarget / 100.0), _Digits);
      double sl = NormalizeDouble(orbHigh - (orbRange * stopLoss / 100.0), _Digits);
      
      Print("üìä Breakout signal detected | Closed Bar: ", closedBarClose, " > ORB High: ", orbHigh);
      
      ulong ticket = OpenTrade(ORDER_TYPE_BUY, sl, tp, dayOfWeek);
      if(ticket > 0)
      {
         tradeTakenToday = true;
      }
   }
   
   // Check for breakdown (sell signal) - closed bar must close below ORB Low
   if(tradeBreakdown && !tradeTakenToday && closedBarClose < orbLow)
   {
      double tp = NormalizeDouble(orbLow - (orbRange * profitTarget / 100.0), _Digits);
      double sl = NormalizeDouble(orbLow + (orbRange * stopLoss / 100.0), _Digits);
      
      Print("üìä Breakdown signal detected | Closed Bar: ", closedBarClose, " < ORB Low: ", orbLow);
      
      ulong ticket = OpenTrade(ORDER_TYPE_SELL, sl, tp, dayOfWeek);
      if(ticket > 0)
      {
         tradeTakenToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Open a trade with virtual TP/SL                                  |
//+------------------------------------------------------------------+
ulong OpenTrade(ENUM_ORDER_TYPE orderType, double sl, double tp, int dayOfWeek)
{
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = NormalizeDouble(InpLotSize, 2);
   request.type = orderType;
   request.price = NormalizeDouble((orderType == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID), _Digits);
   request.sl = 0;  // No broker SL - using virtual
   request.tp = 0;  // No broker TP - using virtual
   request.deviation = 10;
   request.magic = 123456;
   request.comment = "ORB Virtual";
   
   int filling = (int)SymbolInfoInteger(_Symbol, SYMBOL_FILLING_MODE);
   if((filling & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC)
      request.type_filling = ORDER_FILLING_IOC;
   else if((filling & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK)
      request.type_filling = ORDER_FILLING_FOK;
   else
      request.type_filling = ORDER_FILLING_RETURN;
   
   bool success = OrderSend(request, result);
   
   if(result.retcode == 10009 || result.retcode == 10008)
   {
      // Find the opened position and add virtual TP/SL
      for(int i = 0; i < PositionsTotal(); i++)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionGetInteger(POSITION_MAGIC) == 123456 && PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            bool activateMoveStop = GetActivateMoveStop(dayOfWeek);
            
            int size = ArraySize(virtualPositions);
            ArrayResize(virtualPositions, size + 1);
            virtualPositions[size].ticket = ticket;
            virtualPositions[size].virtualTP = NormalizeDouble(tp, _Digits);
            virtualPositions[size].virtualSL = NormalizeDouble(sl, _Digits);
            virtualPositions[size].moveStopTriggered = false;
            virtualPositions[size].isLong = (orderType == ORDER_TYPE_BUY);
            
            if(activateMoveStop)
            {
               double triggerPercent = GetTriggerPercent(dayOfWeek);
               double targetPercent = GetTargetPercent(dayOfWeek);
               double orbRange = orbHigh - orbLow;
               
               double targetDistance = MathAbs(tp - openPrice);
               virtualPositions[size].triggerPrice = openPrice + (orderType == ORDER_TYPE_BUY ? 1 : -1) * (targetDistance * triggerPercent / 100.0);
               virtualPositions[size].targetSL = openPrice + (orderType == ORDER_TYPE_BUY ? 1 : -1) * (orbRange * targetPercent / 100.0);
            }
            else
            {
               virtualPositions[size].triggerPrice = 0;
               virtualPositions[size].targetSL = 0;
            }
            
            Print("‚úì ", (orderType == ORDER_TYPE_BUY ? "LONG" : "SHORT"), " opened | Entry: ", openPrice, 
                  " | Virtual TP: ", tp, " | Virtual SL: ", sl, " | Lot: ", InpLotSize);
            break;
         }
      }
      
      return result.order;
   }
   else
   {
      Print("‚ùå Trade failed: ", result.retcode, " - ", result.comment);
   }
   
   return 0;
}

//+------------------------------------------------------------------+
//| Check Virtual TP/SL on every tick                                |
//+------------------------------------------------------------------+
void CheckVirtualTPSL()
{
   for(int i = ArraySize(virtualPositions) - 1; i >= 0; i--)
   {
      ulong ticket = virtualPositions[i].ticket;
      
      // Check if position still exists
      if(!PositionSelectByTicket(ticket))
      {
         ArrayRemove(virtualPositions, i, 1);
         continue;
      }
      
      double currentPrice = virtualPositions[i].isLong ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      // Check Global Virtual SL (dollar-based per trade)
      if(InpMaxLossPerTrade > 0)
      {
         double currentProfit = PositionGetDouble(POSITION_PROFIT);
         double currentSwap = PositionGetDouble(POSITION_SWAP);
         double totalPL = currentProfit + currentSwap;
         
         if(totalPL <= -InpMaxLossPerTrade)
         {
            if(trade.PositionClose(ticket))
            {
               Print("üí∞ Global Virtual SL hit at ", currentPrice, " | SL Type: Dollar-Based ($", DoubleToString(InpMaxLossPerTrade, 2), ") | Loss: $", DoubleToString(MathAbs(totalPL), 2), " | Position #", ticket, " closed");
               ArrayRemove(virtualPositions, i, 1);
            }
            continue;
         }
      }
      
      // Check if move stop should be triggered
      if(!virtualPositions[i].moveStopTriggered && virtualPositions[i].triggerPrice > 0)
      {
         bool triggerHit = false;
         if(virtualPositions[i].isLong && currentPrice >= virtualPositions[i].triggerPrice)
            triggerHit = true;
         else if(!virtualPositions[i].isLong && currentPrice <= virtualPositions[i].triggerPrice)
            triggerHit = true;
         
         if(triggerHit)
         {
            virtualPositions[i].virtualSL = NormalizeDouble(virtualPositions[i].targetSL, _Digits);
            virtualPositions[i].moveStopTriggered = true;
            Print("üîÑ Move Stop activated #", ticket, " | New Virtual SL: ", virtualPositions[i].virtualSL);
         }
      }
      
      // Check Virtual TP
      if((virtualPositions[i].isLong && currentPrice >= virtualPositions[i].virtualTP) ||
         (!virtualPositions[i].isLong && currentPrice <= virtualPositions[i].virtualTP))
      {
         if(trade.PositionClose(ticket))
         {
            Print("üéØ Virtual TP hit at ", currentPrice, " | Position #", ticket, " closed");
            ArrayRemove(virtualPositions, i, 1);
         }
         continue;
      }
      
      // Check Virtual SL
      if((virtualPositions[i].isLong && currentPrice <= virtualPositions[i].virtualSL) ||
         (!virtualPositions[i].isLong && currentPrice >= virtualPositions[i].virtualSL))
      {
         if(trade.PositionClose(ticket))
         {
            string slType = virtualPositions[i].moveStopTriggered ? "Move Stop (Trailing)" : "ORB-Based";
            Print("üõë Virtual SL hit at ", currentPrice, " | SL Type: ", slType, " | SL Level: ", virtualPositions[i].virtualSL, " | Position #", ticket, " closed");
            ArrayRemove(virtualPositions, i, 1);
         }
         continue;
      }
   }
}

//+------------------------------------------------------------------+
//| Check and close positions at session close                       |
//+------------------------------------------------------------------+
void CheckSessionClose()
{
   if(sessionClosed) return;
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   datetime sessionEnd = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                      IntegerToString(timeStruct.mon) + "." + 
                                      IntegerToString(timeStruct.day) + " " +
                                      IntegerToString(InpSessionEndHour) + ":" + 
                                      IntegerToString(InpSessionEndMinute));
   
   if(TimeCurrent() >= sessionEnd)
   {
      int totalPositions = PositionsTotal();
      Print("üïê Session end reached at ", TimeToString(TimeCurrent()), " | Total positions: ", totalPositions, " | Current symbol: ", _Symbol);
      
      int closedCount = 0;
      
      for(int i = totalPositions - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket <= 0)
         {
            Print("‚ö†Ô∏è Invalid ticket at index ", i);
            continue;
         }
         
         string posSymbol = PositionGetString(POSITION_SYMBOL);
         long posMagic = PositionGetInteger(POSITION_MAGIC);
         
         Print("üìã Checking position #", ticket, " | Symbol: ", posSymbol, " | Magic: ", posMagic);
         
         if(posSymbol != _Symbol)
         {
            Print("‚è≠Ô∏è Skipping - Different symbol (", posSymbol, " != ", _Symbol, ")");
            continue;
         }
         
         if(posMagic != 123456)
         {
            Print("‚è≠Ô∏è Skipping - Different magic (", posMagic, " != 123456)");
            continue;
         }
         
         // Get position details before closing
         double closePrice = PositionGetDouble(POSITION_PRICE_CURRENT);
         double profit = PositionGetDouble(POSITION_PROFIT);
         double swap = PositionGetDouble(POSITION_SWAP);
         double totalPL = profit + swap;
         string posType = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? "LONG" : "SHORT";
         
         if(trade.PositionClose(ticket))
         {
            closedCount++;
            Print("üïê EOD Close | ", posType, " Position #", ticket, " closed at ", closePrice, " | P&L: $", DoubleToString(totalPL, 2));
         }
      }
      
      if(closedCount > 0)
      {
         Print("‚úÖ Session closed | ", closedCount, " position(s) closed at ", TimeToString(TimeCurrent()));
      }
      else
      {
         if(totalPositions > 0)
            Print("‚ö†Ô∏è Session end reached but NO positions closed | Total positions: ", totalPositions, " | Symbol: ", _Symbol);
         else
            Print("‚ÑπÔ∏è Session end reached | No open positions");
      }
      
      sessionClosed = true;
   }
}

//+------------------------------------------------------------------+
//| Helper Functions - Day Settings                                  |
//+------------------------------------------------------------------+
bool IsTradingDay(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpTradeMonday;
      case 2: return InpTradeTuesday;
      case 3: return InpTradeWednesday;
      case 4: return InpTradeThursday;
      case 5: return InpTradeFriday;
      default: return false;
   }
}

bool GetBreakoutSetting(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayBreakout;
      case 2: return InpTuesdayBreakout;
      case 3: return InpWednesdayBreakout;
      case 4: return InpThursdayBreakout;
      case 5: return InpFridayBreakout;
      default: return false;
   }
}

bool GetBreakdownSetting(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayBreakdown;
      case 2: return InpTuesdayBreakdown;
      case 3: return InpWednesdayBreakdown;
      case 4: return InpThursdayBreakdown;
      case 5: return InpFridayBreakdown;
      default: return false;
   }
}

double GetProfitTarget(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayProfitTarget;
      case 2: return InpTuesdayProfitTarget;
      case 3: return InpWednesdayProfitTarget;
      case 4: return InpThursdayProfitTarget;
      case 5: return InpFridayProfitTarget;
      default: return 50.0;
   }
}

double GetStopLoss(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayStopLoss;
      case 2: return InpTuesdayStopLoss;
      case 3: return InpWednesdayStopLoss;
      case 4: return InpThursdayStopLoss;
      case 5: return InpFridayStopLoss;
      default: return 100.0;
   }
}

double GetMinORBSize(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayMinORBSize;
      case 2: return InpTuesdayMinORBSize;
      case 3: return InpWednesdayMinORBSize;
      case 4: return InpThursdayMinORBSize;
      case 5: return InpFridayMinORBSize;
      default: return 0.0;
   }
}

double GetMaxORBSize(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayMaxORBSize;
      case 2: return InpTuesdayMaxORBSize;
      case 3: return InpWednesdayMaxORBSize;
      case 4: return InpThursdayMaxORBSize;
      case 5: return InpFridayMaxORBSize;
      default: return 0.5;
   }
}

bool GetActivateMoveStop(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayActivateMoveStop;
      case 2: return InpTuesdayActivateMoveStop;
      case 3: return InpWednesdayActivateMoveStop;
      case 4: return InpThursdayActivateMoveStop;
      case 5: return InpFridayActivateMoveStop;
      default: return false;
   }
}

double GetTriggerPercent(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayTriggerPercent;
      case 2: return InpTuesdayTriggerPercent;
      case 3: return InpWednesdayTriggerPercent;
      case 4: return InpThursdayTriggerPercent;
      case 5: return InpFridayTriggerPercent;
      default: return 85.0;
   }
}

double GetTargetPercent(int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return InpMondayTargetPercent;
      case 2: return InpTuesdayTargetPercent;
      case 3: return InpWednesdayTargetPercent;
      case 4: return InpThursdayTargetPercent;
      case 5: return InpFridayTargetPercent;
      default: return 20.0;
   }
}
//+------------------------------------------------------------------+
