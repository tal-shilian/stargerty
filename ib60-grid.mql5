//+------------------------------------------------------------------+
//|                                                       IB60.mql5 |
//|                        Initial Balance Breakout 60min Strategy   |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "IB Breakout Strategy"
#property link      ""
#property version   "1.02"
#property strict

#include <Trade\Trade.mqh>

CTrade trade;

// Input Parameters
input group "=== Trading Session ==="
input int SessionStartHour = 16;       // Session Start Hour (GMT+2: 16 for US market 9:30 AM EST)
input int SessionStartMinute = 30;     // Session Start Minute
input int SessionEndHour = 23;         // Session End Hour (GMT+2: 23 for US market 4:00 PM EST)
input int SessionEndMinute = 0;        // Session End Minute

input group "=== Strategy Settings ==="
input int IBPeriodMinutes = 60;        // Initial Balance Period (minutes)
input ENUM_TIMEFRAMES CandleTimeframe = PERIOD_M30; // Candle Timeframe for Breakout
input bool BreakoutByClose = true;     // Breakout Measured by Close (vs High/Low)

input group "=== Risk Management ==="
input double RiskPercent = 1.0;        // Risk Percent per Trade
input double LotSize = 0.1;            // Fixed Lot Size (if RiskPercent = 0)
input double StopLossPercent = 0.0;    // Stop Loss % of Entry Price (0 = IB range)
input bool UseTrailingStop = false;    // Use Trailing Stop
input double TrailingStopPercent = 0.5; // Trailing Stop % of Current Price

input group "=== Trade Management ==="
input bool OneTradePerDay = true;      // One Trade Per Day
input bool CloseAtSessionEnd = true;   // Close Positions at Session End
input bool UseOpeningCandleFilter = true; // Use Opening Candle Continuation Filter

input group "=== Partial Take Profit ==="
input bool UsePartialTP = true;        // Use Partial Take Profit
input double TP1_Multiplier = 0.5;     // TP1: IB Range Multiplier
input double TP1_ClosePercent = 33.0;  // TP1: % of Position to Close
input double TP2_Multiplier = 1.0;     // TP2: IB Range Multiplier
input double TP2_ClosePercent = 33.0;  // TP2: % of Position to Close
input double TP3_Multiplier = 2.0;     // TP3: IB Range Multiplier (Final)
input bool MoveToBreakEven = true;     // Move SL to Break-Even After TP1

// Global Variables
double ibHigh = 0;
double ibLow = 0;
bool ibFormed = false;
bool tradeTakenToday = false;
datetime currentDay = 0;
datetime ibStartTime = 0;
datetime ibEndTime = 0;
bool longBreakout = false;
bool shortBreakout = false;
bool openingCandleBullish = false;  // Opening candle direction
bool openingCandleSet = false;       // Opening candle analyzed

// Partial TP tracking
ulong mainTicket = 0;           // Main position ticket
double initialLots = 0;         // Initial position size
bool tp1Hit = false;            // TP1 reached
bool tp2Hit = false;            // TP2 reached
bool movedToBreakEven = false;  // SL moved to break-even

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("IB60 Strategy Initialized");
   Print("IB Period: ", IBPeriodMinutes, " minutes");
   Print("Session: ", SessionStartHour, ":", SessionStartMinute, " - ", SessionEndHour, ":", SessionEndMinute);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("IB60 Strategy Deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check if new day
   datetime now = TimeCurrent();
   MqlDateTime timeStruct;
   TimeToStruct(now, timeStruct);
   
   datetime todayDate = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                      IntegerToString(timeStruct.mon) + "." + 
                                      IntegerToString(timeStruct.day));
   
   if(todayDate != currentDay)
   {
      // New day - reset variables
      currentDay = todayDate;
      ibFormed = false;
      tradeTakenToday = false;
      ibHigh = 0;
      ibLow = 0;
      longBreakout = false;
      shortBreakout = false;
      openingCandleSet = false;
      
      // Reset partial TP tracking
      mainTicket = 0;
      initialLots = 0;
      tp1Hit = false;
      tp2Hit = false;
      movedToBreakEven = false;
      
      // Calculate IB start and end times for today
      ibStartTime = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                  IntegerToString(timeStruct.mon) + "." + 
                                  IntegerToString(timeStruct.day) + " " +
                                  IntegerToString(SessionStartHour) +":" + 
                                  IntegerToString(SessionStartMinute));
      ibEndTime = ibStartTime + IBPeriodMinutes * 60;
   }
   
   // Check if we're in trading session
   if(!IsInTradingSession(now))
   {
      if(CloseAtSessionEnd && PositionsTotal() > 0)
      {
         CloseAllPositions();
      }
      return;
   }
   
   // Form Initial Balance after period ends (wait for M30 candles to be indexed)
   // We need to be past 17:30 for the 17:00-17:30 candle to be available as bar 1
   if(!ibFormed && now >= ibEndTime + 60)  // Wait 1 minute after IB period ends
   {
      UpdateInitialBalance();
      
      if(ibHigh > 0 && ibLow > 0)
      {
         ibFormed = true;
         Print("✓ IB Formed - High: ", ibHigh, " Low: ", ibLow);
         
         // Analyze opening candle direction (60-min IB candle)
         if(UseOpeningCandleFilter && !openingCandleSet)
         {
            double ibOpen = iOpen(_Symbol, PERIOD_H1, 1);   // Opening price of IB period
            double ibClose = iClose(_Symbol, PERIOD_H1, 1); // Closing price of IB period
            openingCandleBullish = (ibClose > ibOpen);
            openingCandleSet = true;
            
            string direction = openingCandleBullish ? "Bullish" : "Bearish";
            Print("✓ Opening Candle (60min): ", direction, " | Open: ", ibOpen, " Close: ", ibClose);
         }
      }
      else
      {
         Print("✗ IB Formation FAILED - No candles found for today");
      }
   }
   
   // Check for breakout after IB is formed
   if(ibFormed && (!OneTradePerDay || !tradeTakenToday))
   {
      CheckForBreakout();
   }
   
   // Manage partial take profit
   if(UsePartialTP && mainTicket > 0)
   {
      ManagePartialTP();
   }
   
   // Manage trailing stop
   if(UseTrailingStop)
   {
      ManageTrailingStop();
   }
}

//+------------------------------------------------------------------+
//| Check if current time is in trading session                      |
//+------------------------------------------------------------------+
bool IsInTradingSession(datetime time)
{
   MqlDateTime timeStruct;
   TimeToStruct(time, timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int startMinutes = SessionStartHour * 60 + SessionStartMinute;
   int endMinutes = SessionEndHour * 60 + SessionEndMinute;
   
   return (currentMinutes >= startMinutes && currentMinutes < endMinutes);
}

//+------------------------------------------------------------------+
//| Update Initial Balance high and low using M30 candles            |
//+------------------------------------------------------------------+
void UpdateInitialBalance()
{
   Print("Looking for IB candles. IB Period: ", TimeToString(ibStartTime, TIME_DATE|TIME_MINUTES), " - ", TimeToString(ibEndTime, TIME_MINUTES));
   
   // We need 2 M30 candles: 16:30-17:00 and 17:00-17:30
   // Look back through recent M30 candles to find those in the IB period
   int candlesFound = 0;
   
   for(int i = 1; i <= 10; i++)
   {
      datetime candleTime = iTime(_Symbol, PERIOD_M30, i);
      datetime candleEndTime = candleTime + 1800; // M30 candle ends 30 min later
      
      Print("  Checking bar ", i, ": ", TimeToString(candleTime, TIME_DATE|TIME_MINUTES), " (ends ", TimeToString(candleEndTime, TIME_MINUTES), ")");
      
      // Check if this M30 candle is from today AND starts within the IB period
      // We want candles at 16:30 and 17:00 (both start before 17:30) from the same day
      MqlDateTime candleStruct, ibStruct;
      TimeToStruct(candleTime, candleStruct);
      TimeToStruct(ibStartTime, ibStruct);
      
      bool sameDay = (candleStruct.year == ibStruct.year && 
                      candleStruct.mon == ibStruct.mon && 
                      candleStruct.day == ibStruct.day);
      
      if(sameDay && candleTime >= ibStartTime && candleTime < ibEndTime)
      {
         double high = iHigh(_Symbol, PERIOD_M30, i);
         double low = iLow(_Symbol, PERIOD_M30, i);
         
         if(ibHigh == 0 || high > ibHigh)
            ibHigh = high;
         
         if(ibLow == 0 || low < ibLow)
            ibLow = low;
         
         candlesFound++;
         Print("  >>> IB M30 Candle ", candlesFound, " at bar ", i, ": ", TimeToString(candleTime, TIME_MINUTES), " H=", high, " L=", low);
      }
      else
      {
         MqlDateTime candleStruct, ibStruct;
         TimeToStruct(candleTime, candleStruct);
         TimeToStruct(ibStartTime, ibStruct);
         bool sameDay = (candleStruct.year == ibStruct.year && candleStruct.mon == ibStruct.mon && candleStruct.day == ibStruct.day);
         
         if(!sameDay)
            Print("  ... Bar ", i, " is from different day");
         else
            Print("  ... Bar ", i, " outside IB period (need >= ", TimeToString(ibStartTime, TIME_MINUTES), " and < ", TimeToString(ibEndTime, TIME_MINUTES), ")");
      }
   }
   
   if(ibHigh > 0 && ibLow > 0)
   {
      Print(">>> IB Formed from ", candlesFound, " M30 candles: H=", ibHigh, " L=", ibLow, " Range=", (ibHigh-ibLow)/_Point, " points");
   }
   else
   {
      Print("!!! IB NOT FOUND - No M30 candles in period ", TimeToString(ibStartTime, TIME_MINUTES), " - ", TimeToString(ibEndTime, TIME_MINUTES));
   }
}

//+------------------------------------------------------------------+
//| Check for breakout of Initial Balance                            |
//+------------------------------------------------------------------+
void CheckForBreakout()
{
   // Get current candle data on the specified timeframe
   double close = iClose(_Symbol, CandleTimeframe, 1);  // Use bar 1 (last completed candle)
   double high = iHigh(_Symbol, CandleTimeframe, 1);
   double low = iLow(_Symbol, CandleTimeframe, 1);
   datetime candleTime = iTime(_Symbol, CandleTimeframe, 1);
   
   static datetime lastCheckedCandle = 0;
   if(candleTime == lastCheckedCandle)
      return;  // Already checked this candle
   
   lastCheckedCandle = candleTime;
   Print("Checking breakout on candle: ", TimeToString(candleTime, TIME_MINUTES), " Close=", close, " IB High=", ibHigh, " IB Low=", ibLow);
   
   // Check for long breakout
   if(!longBreakout && PositionsTotal() == 0)
   {
      bool breakout = false;
      
      if(BreakoutByClose)
         breakout = (close > ibHigh);
      else
         breakout = (high > ibHigh);
      
      // Apply opening candle filter
      if(UseOpeningCandleFilter && !openingCandleBullish)
      {
         if(breakout)
            Print("⊘ Long breakout ignored - Opening candle was bearish");
         breakout = false;
      }
      
      if(breakout)
      {
         longBreakout = true;
         OpenLongPosition();
         tradeTakenToday = true;
         if(OneTradePerDay) return;
      }
   }
   
   // Check for short breakout
   if(!shortBreakout && PositionsTotal() == 0)
   {
      bool breakout = false;
      
      if(BreakoutByClose)
         breakout = (close < ibLow);
      else
         breakout = (low < ibLow);
      
      // Apply opening candle filter
      if(UseOpeningCandleFilter && openingCandleBullish)
      {
         if(breakout)
            Print("⊘ Short breakout ignored - Opening candle was bullish");
         breakout = false;
      }
      
      if(breakout)
      {
         shortBreakout = true;
         OpenShortPosition();
         tradeTakenToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Open Long Position                                                |
//+------------------------------------------------------------------+
void OpenLongPosition()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl = 0;
   double tp = 0;
   
   // Calculate Stop Loss
   if(StopLossPercent > 0)
   {
      sl = price - (price * StopLossPercent / 100.0);
   }
   else
   {
      sl = ibLow; // Use IB low as stop loss
   }
   
   // Calculate Take Profit based on IB range
   double ibRange = ibHigh - ibLow;
   double tpMultiplier = UsePartialTP ? TP3_Multiplier : 2.0;
   tp = price + (ibRange * tpMultiplier);
   
   // Calculate lot size
   double lots = CalculateLotSize(price - sl);
   
   if(trade.Buy(lots, _Symbol, price, sl, tp, "IB60 Long"))
   {
      mainTicket = trade.ResultOrder();
      initialLots = lots;
      Print("Long position opened at ", price, " SL: ", sl, " TP: ", tp, " Lots: ", lots);
      if(UsePartialTP)
         Print("Partial TP enabled: TP1=", TP1_Multiplier, "x (", TP1_ClosePercent, "%), TP2=", TP2_Multiplier, "x (", TP2_ClosePercent, "%), TP3=", TP3_Multiplier, "x");
   }
   else
   {
      Print("Failed to open long position. Error: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Open Short Position                                               |
//+------------------------------------------------------------------+
void OpenShortPosition()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl = 0;
   double tp = 0;
   
   // Calculate Stop Loss
   if(StopLossPercent > 0)
   {
      sl = price + (price * StopLossPercent / 100.0);
   }
   else
   {
      sl = ibHigh; // Use IB high as stop loss
   }
   
   // Calculate Take Profit based on IB range
   double ibRange = ibHigh - ibLow;
   double tpMultiplier = UsePartialTP ? TP3_Multiplier : 2.0;
   tp = price - (ibRange * tpMultiplier);
   
   // Calculate lot size
   double lots = CalculateLotSize(sl - price);
   
   if(trade.Sell(lots, _Symbol, price, sl, tp, "IB60 Short"))
   {
      mainTicket = trade.ResultOrder();
      initialLots = lots;
      Print("Short position opened at ", price, " SL: ", sl, " TP: ", tp, " Lots: ", lots);
      if(UsePartialTP)
         Print("Partial TP enabled: TP1=", TP1_Multiplier, "x (", TP1_ClosePercent, "%), TP2=", TP2_Multiplier, "x (", TP2_ClosePercent, "%), TP3=", TP3_Multiplier, "x");
   }
   else
   {
      Print("Failed to open short position. Error: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size based on risk                                 |
//+------------------------------------------------------------------+
double CalculateLotSize(double slDistance)
{
   if(RiskPercent <= 0)
      return LotSize;
   
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * RiskPercent / 100.0;
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   
   double slInTicks = slDistance / tickSize;
   double lots = riskAmount / (slInTicks * tickValue);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lots = MathFloor(lots / lotStep) * lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));
   
   return lots;
}

//+------------------------------------------------------------------+
//| Manage Trailing Stop                                             |
//+------------------------------------------------------------------+
void ManageTrailingStop()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      
      double positionOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      
      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
      {
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double newSL = currentPrice - (currentPrice * TrailingStopPercent / 100.0);
         
         if(newSL > currentSL && newSL < currentPrice)
         {
            trade.PositionModify(ticket, newSL, currentTP);
            Print("Trailing stop updated for long position. New SL: ", newSL);
         }
      }
      else if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
      {
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double newSL = currentPrice + (currentPrice * TrailingStopPercent / 100.0);
         
         if(newSL < currentSL && newSL > currentPrice)
         {
            trade.PositionModify(ticket, newSL, currentTP);
            Print("Trailing stop updated for short position. New SL: ", newSL);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Manage Partial Take Profit                                       |
//+------------------------------------------------------------------+
void ManagePartialTP()
{
   // Check if position still exists
   if(!PositionSelectByTicket(mainTicket))
   {
      mainTicket = 0;
      return;
   }
   
   double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentPrice = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double currentLots = PositionGetDouble(POSITION_VOLUME);
   
   double ibRange = ibHigh - ibLow;
   bool isLong = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY);
   
   // Calculate profit in IB range multiples
   double profitMultiple = isLong ? 
                          (currentPrice - entryPrice) / ibRange : 
                          (entryPrice - currentPrice) / ibRange;
   
   // Check TP1
   if(!tp1Hit && profitMultiple >= TP1_Multiplier)
   {
      double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double closeVolume = MathFloor((initialLots * TP1_ClosePercent / 100.0) / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume <= currentLots)
      {
         if(trade.PositionClosePartial(mainTicket, closeVolume))
         {
            tp1Hit = true;
            Print("✓ TP1 Hit (", TP1_Multiplier, "x IB): Closed ", TP1_ClosePercent, "% (", closeVolume, " lots) at ", currentPrice);
            
            // Move to break-even after TP1
            if(MoveToBreakEven && !movedToBreakEven)
            {
               double currentSL = PositionGetDouble(POSITION_SL);
               double currentTP = PositionGetDouble(POSITION_TP);
               
               if(trade.PositionModify(mainTicket, entryPrice, currentTP))
               {
                  movedToBreakEven = true;
                  Print("✓ Stop Loss moved to Break-Even: ", entryPrice);
               }
            }
         }
      }
   }
   
   // Check TP2
   if(tp1Hit && !tp2Hit && profitMultiple >= TP2_Multiplier)
   {
      // Close percentage of remaining position
      double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      
      // Calculate from current remaining lots, not initial
      double closeVolume = MathFloor((currentLots * TP2_ClosePercent / 100.0) / lotStep) * lotStep;
      
      if(closeVolume >= minLot && closeVolume <= currentLots)
      {
         if(trade.PositionClosePartial(mainTicket, closeVolume))
         {
            tp2Hit = true;
            Print("✓ TP2 Hit (", TP2_Multiplier, "x IB): Closed ", TP2_ClosePercent, "% of remaining (", closeVolume, " lots) at ", currentPrice);
         }
      }
   }
   
   // TP3 is handled by the main TP order
}

//+------------------------------------------------------------------+
//| Close All Positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         trade.PositionClose(ticket);
         Print("Position closed at session end. Ticket: ", ticket);
      }
   }
}
//+------------------------------------------------------------------+