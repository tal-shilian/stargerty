//+------------------------------------------------------------------+
//|                                                      gap.mql5    |
//|                                    Gap Fill Strategy EA          |
//+------------------------------------------------------------------+
#property copyright "Gap Fill Strategy"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

CTrade trade;

//--- Input Parameters
input group "=== Session Settings ==="
input int SessionStartHour = 16;       // Session Start Hour (GMT+2: 16:30 = 9:30 AM EST)
input int SessionStartMinute = 30;     // Session Start Minute
input int SessionEndHour = 23;         // Session End Hour (GMT+2: 23:00 = 4:00 PM EST)
input int SessionEndMinute = 0;        // Session End Minute

input group "=== Monday Settings ==="
input bool MondayGapUp = true;         // Monday: Trade Gap Up
input bool MondayGapDown = true;       // Monday: Trade Gap Down
input double MondayGapFillTarget = 100.0;  // Monday: Gap Fill Target %
input double MondayRiskReward = 0.5;   // Monday: Risk to Reward
input double MondayMinGapSize = 0.0;   // Monday: Min Gap Size %
input double MondayMaxGapSize = 0.5;   // Monday: Max Gap Size %

input group "=== Tuesday Settings ==="
input bool TuesdayGapUp = true;        // Tuesday: Trade Gap Up
input bool TuesdayGapDown = true;      // Tuesday: Trade Gap Down
input double TuesdayGapFillTarget = 100.0; // Tuesday: Gap Fill Target %
input double TuesdayRiskReward = 0.5;  // Tuesday: Risk to Reward
input double TuesdayMinGapSize = 0.0;  // Tuesday: Min Gap Size %
input double TuesdayMaxGapSize = 0.5;  // Tuesday: Max Gap Size %

input group "=== Wednesday Settings ==="
input bool WednesdayGapUp = true;      // Wednesday: Trade Gap Up
input bool WednesdayGapDown = true;    // Wednesday: Trade Gap Down
input double WednesdayGapFillTarget = 100.0; // Wednesday: Gap Fill Target %
input double WednesdayRiskReward = 0.5; // Wednesday: Risk to Reward
input double WednesdayMinGapSize = 0.0; // Wednesday: Min Gap Size %
input double WednesdayMaxGapSize = 0.5; // Wednesday: Max Gap Size %

input group "=== Thursday Settings ==="
input bool ThursdayGapUp = true;       // Thursday: Trade Gap Up
input bool ThursdayGapDown = true;     // Thursday: Trade Gap Down
input double ThursdayGapFillTarget = 100.0; // Thursday: Gap Fill Target %
input double ThursdayRiskReward = 0.5; // Thursday: Risk to Reward
input double ThursdayMinGapSize = 0.0; // Thursday: Min Gap Size %
input double ThursdayMaxGapSize = 0.5; // Thursday: Max Gap Size %

input group "=== Friday Settings ==="
input bool FridayGapUp = true;         // Friday: Trade Gap Up
input bool FridayGapDown = true;       // Friday: Trade Gap Down
input double FridayGapFillTarget = 100.0; // Friday: Gap Fill Target %
input double FridayRiskReward = 0.5;   // Friday: Risk to Reward
input double FridayMinGapSize = 0.0;   // Friday: Min Gap Size %
input double FridayMaxGapSize = 0.5;   // Friday: Max Gap Size %

input group "=== Trade Management ==="
input double RiskPercent = 1.0;        // Risk % of Account Balance
input double GlobalStopLoss = 0.0;     // Global Stop Loss $ (0 = disabled)
input int MagicNumber = 20251123;      // Magic Number
input string TradeComment = "GapFill"; // Trade Comment

//--- Global Variables
double previousSessionClose = 0.0;
double currentSessionOpen = 0.0;
double gapSize = 0.0;
bool tradeToday = false;
bool isGapUp = false;
datetime lastTradeDate = 0;
bool sessionCloseRecorded = false;
double startingBalance = 0.0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);
   startingBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   Print("Gap Fill EA initialized | Starting Balance: $", startingBalance);
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("Gap Fill EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check global stop loss
   if(GlobalStopLoss > 0)
   {
      double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      double totalLoss = startingBalance - currentBalance;
      
      if(totalLoss >= GlobalStopLoss)
      {
         CloseAllPositions();
         Print("GLOBAL STOP LOSS HIT: $", totalLoss, " | EA Stopped");
         ExpertRemove();
         return;
      }
   }
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   datetime currentDate = StringToTime(IntegerToString(timeStruct.year) + "." + 
                                       IntegerToString(timeStruct.mon) + "." + 
                                       IntegerToString(timeStruct.day));
   
   bool withinSession = IsWithinSession();
   
   // Record previous session close when session ends
   if(!withinSession && !sessionCloseRecorded)
   {
      double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      if(currentPrice > 0)
      {
         previousSessionClose = currentPrice;
         sessionCloseRecorded = true;
         Print("Session closed at: ", previousSessionClose);
      }
   }
   
   // Reset on new day
   if(currentDate != lastTradeDate)
   {
      tradeToday = false;
      lastTradeDate = currentDate;
      sessionCloseRecorded = false;
      currentSessionOpen = 0.0;
      gapSize = 0.0;
   }
   
   // Check if within session time
   if(!withinSession)
      return;
   
   // Record session open and calculate gap
   if(currentSessionOpen == 0.0 && previousSessionClose > 0.0)
   {
      currentSessionOpen = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      CalculateGap();
   }
   
   // Check if already traded today
   if(tradeToday)
   {
      ManageOpenPositions();
      return;
   }
   
   // Check for entry signal
   CheckEntrySignal();
}

//+------------------------------------------------------------------+
//| Calculate gap size and direction                                 |
//+------------------------------------------------------------------+
void CalculateGap()
{
   // Calculate gap between previous session close and current session open
   if(previousSessionClose > 0 && currentSessionOpen > 0)
   {
      gapSize = MathAbs(currentSessionOpen - previousSessionClose) / previousSessionClose * 100.0;
      isGapUp = currentSessionOpen > previousSessionClose;
      
      Print("Gap detected: ", isGapUp ? "Gap Up" : "Gap Down", 
            " | Size: ", DoubleToString(gapSize, 2), "%",
            " | Previous Session Close: ", previousSessionClose,
            " | Current Session Open: ", currentSessionOpen);
   }
}

//+------------------------------------------------------------------+
//| Check if current time is within session                          |
//+------------------------------------------------------------------+
bool IsWithinSession()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   int sessionStart = SessionStartHour * 60 + SessionStartMinute;
   int sessionEnd = SessionEndHour * 60 + SessionEndMinute;
   
   // Handle case where session crosses midnight
   if(sessionEnd < sessionStart)
      return (currentMinutes >= sessionStart || currentMinutes < sessionEnd);
   else
      return (currentMinutes >= sessionStart && currentMinutes < sessionEnd);
}

//+------------------------------------------------------------------+
//| Get day-specific settings                                        |
//+------------------------------------------------------------------+
void GetDaySettings(bool &gapUpEnabled, bool &gapDownEnabled, 
                    double &fillTarget, double &riskReward,
                    double &minGap, double &maxGap)
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   switch(timeStruct.day_of_week)
   {
      case 1: // Monday
         gapUpEnabled = MondayGapUp;
         gapDownEnabled = MondayGapDown;
         fillTarget = MondayGapFillTarget;
         riskReward = MondayRiskReward;
         minGap = MondayMinGapSize;
         maxGap = MondayMaxGapSize;
         break;
      case 2: // Tuesday
         gapUpEnabled = TuesdayGapUp;
         gapDownEnabled = TuesdayGapDown;
         fillTarget = TuesdayGapFillTarget;
         riskReward = TuesdayRiskReward;
         minGap = TuesdayMinGapSize;
         maxGap = TuesdayMaxGapSize;
         break;
      case 3: // Wednesday
         gapUpEnabled = WednesdayGapUp;
         gapDownEnabled = WednesdayGapDown;
         fillTarget = WednesdayGapFillTarget;
         riskReward = WednesdayRiskReward;
         minGap = WednesdayMinGapSize;
         maxGap = WednesdayMaxGapSize;
         break;
      case 4: // Thursday
         gapUpEnabled = ThursdayGapUp;
         gapDownEnabled = ThursdayGapDown;
         fillTarget = ThursdayGapFillTarget;
         riskReward = ThursdayRiskReward;
         minGap = ThursdayMinGapSize;
         maxGap = ThursdayMaxGapSize;
         break;
      case 5: // Friday
         gapUpEnabled = FridayGapUp;
         gapDownEnabled = FridayGapDown;
         fillTarget = FridayGapFillTarget;
         riskReward = FridayRiskReward;
         minGap = FridayMinGapSize;
         maxGap = FridayMaxGapSize;
         break;
      default:
         gapUpEnabled = false;
         gapDownEnabled = false;
         fillTarget = 100.0;
         riskReward = 0.5;
         minGap = 0.0;
         maxGap = 0.5;
         break;
   }
}

//+------------------------------------------------------------------+
//| Check for entry signal                                           |
//+------------------------------------------------------------------+
void CheckEntrySignal()
{
   if(gapSize <= 0 || previousSessionClose <= 0)
      return;
   
   // Get day-specific settings
   bool gapUpEnabled, gapDownEnabled;
   double fillTarget, riskReward, minGap, maxGap;
   GetDaySettings(gapUpEnabled, gapDownEnabled, fillTarget, riskReward, minGap, maxGap);
   
   // Check gap size filters
   if(gapSize < minGap || gapSize > maxGap)
   {
      Print("Gap size ", gapSize, "% outside range [", minGap, "%, ", maxGap, "%]");
      return;
   }
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double targetPrice = previousSessionClose;
   double gapDistance = MathAbs(currentSessionOpen - previousSessionClose);
   
   // Adjust target based on fill percentage
   if(fillTarget < 100.0)
   {
      if(isGapUp)
         targetPrice = currentSessionOpen - (gapDistance * fillTarget / 100.0);
      else
         targetPrice = currentSessionOpen + (gapDistance * fillTarget / 100.0);
   }
   
   // Gap Up - Short back to previous session close
   if(isGapUp && gapUpEnabled)
   {
      double stopDistance = gapDistance * riskReward;
      double sl = currentSessionOpen + stopDistance;
      double tp = targetPrice;
      double lotSize = CalculateLotSize(stopDistance);
      
      if(trade.Sell(lotSize, _Symbol, 0, sl, tp, TradeComment))
      {
         Print("Gap Up SHORT opened | Entry: ", currentPrice, " | SL: ", sl, " | TP: ", tp, " | Lot: ", lotSize);
         tradeToday = true;
      }
   }
   // Gap Down - Long back to previous session close
   else if(!isGapUp && gapDownEnabled)
   {
      double stopDistance = gapDistance * riskReward;
      double sl = currentSessionOpen - stopDistance;
      double tp = targetPrice;
      double lotSize = CalculateLotSize(stopDistance);
      
      if(trade.Buy(lotSize, _Symbol, 0, sl, tp, TradeComment))
      {
         Print("Gap Down LONG opened | Entry: ", currentPrice, " | SL: ", sl, " | TP: ", tp, " | Lot: ", lotSize);
         tradeToday = true;
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate lot size based on risk percentage                      |
//+------------------------------------------------------------------+
double CalculateLotSize(double stopDistance)
{
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * RiskPercent / 100.0;
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // Calculate lot size based on risk
   double lotSize = riskAmount / (stopDistance / tickSize * tickValue);
   
   // Round to lot step
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   
   // Ensure within min/max limits
   if(lotSize < minLot) lotSize = minLot;
   if(lotSize > maxLot) lotSize = maxLot;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Manage open positions                                            |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
   // Check if position still exists
   if(!PositionSelect(_Symbol))
   {
      // Position closed, allow new trade tomorrow
      return;
   }
   
   // Additional position management logic can be added here
   // (trailing stops, partial closes, etc.)
}

//+------------------------------------------------------------------+
//| Close all positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         {
            trade.PositionClose(ticket);
            Print("Position closed due to global stop loss: ", ticket);
         }
      }
   }
}
//+------------------------------------------------------------------+
